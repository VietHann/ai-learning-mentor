[
  {
    "chunk_id": "fe75eeaf-e542-4958-bb4d-53fb4bc4bea5",
    "content": "[PAGE 1]\nCHƯƠNG 5: Lập trình với giao thức UDP Giảng viên: Ths. Phạm Văn Tiệp Slide: số….\n\n[PAGE 2]\nNội dung bài học ▪ Tổng quan về giao thức UDP ▪ Lớp DatagramPacket ▪ Lớp DatagramSocket ▪ Nhận các gói tin ▪ Gửi các gói tin SlideS:li dseố: …số .2\n\n[PAGE 3]\nTổng quan về UDP Slide: số….\n\n[PAGE 4]\nUDP là gì? UDP (User Datagram Protocol) giao thức dữ liệu người dùng là một giao ▪ thức được dùng để truyền tải dữ liệu giữa các thiết bị mạng Không yêu cầu người dùng thiết lập kết nối liên tục giữa nguồn và đích ▪ Nguyên lý hoạt động: ▪ Gửi và nhận thông qua Datagram o Không thiết lập kết nối o Không đảm bảo tính tin cậy o Hỗ trợ tích hợp với IP o Slide: số….\n\n[PAGE 5]\nƯu và nhược điểm Ưu điểm: ▪ Tốc độ và hiệu suất cao o Ít tốn tài nguyên hệ thống o Xử lý thời gian thực và độ trễ thấp o Hỗ trợ Boardcast và Multicast o Đơn giản và dễ triển khai o Nhược điểm: ▪ Không có cơ chế kiểm tra lỗi và gửi lại dữ liệu nếu bị mất o Không cung cấp cơ chế mã hoá và bảo mật mạnh mẽ như TCP nên rất dễ o bị tấn công hoặc đánh cắp dữ liệu Slide: số….\n\n[PAGE 6]\nLớp DatagramPacket Slide: số….\n\n[PAGE 7]\nLớp DatagramPacket Cung cấp các phương thức để nhận và thiết lập: ▪ Địa chỉ nguồn, đích o Nhận và thiết lập các thông tin về cổng nguồn và đích o Nhận và thiết lập độ dài dữ liệu. o DatagramPacket sử dụng các phương thức khởi tạo khác nhau tùy thuộc vào ▪ gói tin được sử dụng để gửi hay nhận dữ liệu. Slide: số….\n\n[PAGE 8]\nKhởi tạo DatagramPacket để nhận DatagramPacket(byte[] buf, int length) ▪ Khởi tạo DatagramPacket để nhận dữ liệu có kích thước length và lưu o trên buf Chú ý: length ≤ buf.length() o DatagramPacket(byte[] buf,int offset, int length) ▪ Lưu dữ liệu trên buf từ vị trí offset o Chú ý: length ≤ buf.length()−offset o Slide: số….\n\n[PAGE 9]\nKhởi tạo DatagramPacket để gửi DatagramPacket(byte[] buf, int length, InetAddress address, int port) ▪ buf: chứa dữ liệu cần gửi o length: kích thước dữ liệu o port: cổng nhận o address: nút mạng nhận o DatagramPacket(byte[] buf, int offset, int length, InetAddress address, int ▪ port) offset: vị trí bắt đầu của dữ liệu cần gửi trên buf o Slide: số….\n\n[PAGE 10]\nCác phương thức InetAddress getAddress() ▪ int getPort() ▪ byte[] getData(): trả về mảng byte chứa dữ liệu ▪ int getLength() ▪ void setAddress(InetAddress iaddr) ▪ void setPort(int iport) ▪ void setData(byte[] buf) ▪ Slide: số….\n\n[PAGE 11]\nLớp DatagramSocket Slide: số….\n\n[PAGE 12]\nLớp DatagramSocket DatagramSocket được sử dụng để gửi và nhận các gói tin UDP ▪ Các phương thức khởi tạo: ▪ DatagramSocket(int port): khởi tạo với cổng chỉ định o DatagramSocket(int port, InetAddress laddr): khởi tạo với cổng và địa chỉ IP o chỉ định Các phương thức trao đổi dữ liệu: ▪ void connect(InetAddress address, int port): kết nối với một socket khác để o trao đổi dữ liệu void receive(DatagramPacket p): nhận dữ liệu o void send(DatagramPacket p): gửi dữ liệu o void close(): đóng socket o o void setSoTimeout(int timeout): thiết lập thời gian chờ (milisecond) Slide: số….\n\n[PAGE 13]\nVí dụ nhận và gửi các gói tin Slide: số….\n\n[PAGE 14]\nVí dụ public class UDPEchoServer { public static void main(String[] args) { try(DatagramSocket servSocket = new DatagramSocket(5050)){ System.out.println(\"Server started\"); servSocket.setSoTimeout(10000); byte[] buff = new byte[1024]; while(true){ try{ DatagramPacket in = new DatagramPacket(buff, buff.length); servSocket.receive(in); DatagramPacket out = new DatagramPacket(in.getData(), in.getLength(), in.getAddress(),in.getPort()); servSocket.send(out); } Slide: số….\n\n[PAGE 15]\nVí dụ catch(SocketTimeoutException e){ System.out.println(\"Timeout!\"); }catch(IOException e){ System.out.println(\"Cannot communicate to client\"); } } }catch(SocketException e){ System.out.println(\"Cannot start server!\"); } } } Slide: số….\n\n[PAGE 16]\nVí dụ public class UDPEchoClient { public static void main(String[] args) { try(DatagramSocket cliSocket = new DatagramSocket(5051)){ try(BufferedReader user = new BufferedReader(new InputStreamReader(System.in)) ){ String message; while(true){ InetAddress servAddr = InetAddress.getByName(“localhost”); System.out.print(\"Send to server: \"); message = user.readLine(); if(message.length() == 0) break; byte[] buff = message.getBytes(\"UTF-8\"); DatagramPacket out = new DatagramPacket(buff, buff. length,servAddr, 5050); cliSocket.send(out); Slide: số….\n\n[PAGE 17]\nVí dụ DatagramPacket in = new DatagramPacket(buff, buff.length); cliSocket.receive(in); message = new String(buff, 0, buff.length,\"UTF-8\"); System.out.println(\"From server: \" + message); } }catch(IOException e){ System.out.println(\"Cannot communicate to server!\"); } }catch(SocketException e){ System.out.println(\"Cannot start client!); } } } Slide: số….\n\n[PAGE 18]\nBài tập 1 Viết chương trình giao tiếp giữa client và server sử dụng giao thức UDP, thực hiện các chức năng sau: • Client truyền 1 chuỗi lên server, server nhận chuỗi này và chuyển nó",
    "source_id": "temp_8bf905e3-6536-4d57-90b7-1f3ecc4e3a7e_5. Lập trình với giao thức UDP (1).pdf",
    "title": "temp_8bf905e3-6536-4d57-90b7-1f3ecc4e3a7e_5. Lập trình với giao thức UDP (1)",
    "section": "",
    "section_level": 0,
    "page": 1,
    "course": "Unknown",
    "semester": "Unknown",
    "language": "vietnamese",
    "doc_type": "pdf",
    "keywords": [
      "datagrampacket",
      "page",
      "slide",
      "length",
      "datagramsocket",
      "byte",
      "void",
      "buff",
      "system",
      "inetaddress"
    ],
    "hash": "d6695bf076b2e0130bae52f3a79bdbb8",
    "created_at": "2025-09-20T12:48:04.323795",
    "start_char": 2,
    "end_char": 4892,
    "chunk_index": 0,
    "point_id": "907519bc-1b99-4627-a2a5-5a474539ac31",
    "vector_index": 0
  },
  {
    "chunk_id": "cbad256c-d4b4-48f8-ae4e-afadd4bf7f5c",
    "content": "= user.readLine(); if(message.length() == 0) break; byte[] buff = message.getBytes(\"UTF-8\"); DatagramPacket out = new DatagramPacket(buff, buff. length,servAddr, 5050); cliSocket.send(out); Slide: số….\n\n[PAGE 17]\nVí dụ DatagramPacket in = new DatagramPacket(buff, buff.length); cliSocket.receive(in); message = new String(buff, 0, buff.length,\"UTF-8\"); System.out.println(\"From server: \" + message); } }catch(IOException e){ System.out.println(\"Cannot communicate to server!\"); } }catch(SocketException e){ System.out.println(\"Cannot start client!); } } } Slide: số….\n\n[PAGE 18]\nBài tập 1 Viết chương trình giao tiếp giữa client và server sử dụng giao thức UDP, thực hiện các chức năng sau: • Client truyền 1 chuỗi lên server, server nhận chuỗi này và chuyển nó thành chữ in hoa sau đó gửi trả kết quả cho client. Client nhận kết quả rồi sau đó xuất ra màn hình kết quả vừa nhận. • Yêu cầu: Sử dụng Multithread để server có thể giao tiếp được với nhiều client cùng lúc. Slide: số….\n\n[PAGE 19]\nBài tập 2 Viết chương trình giao tiếp giữa client và server sử dụng giao thức UDP, thực hiện các chức năng sau: • Client truyền hai số nguyên và phép toán (cộng, trừ, nhân, chia) lên server, server sau khi nhận được thì thực hiện phép toán giữa hai số nguyên và trả kết quả về cho client, client nhận lại kết quả và xuất ra màn hình. • Yêu cầu: Sử dụng Multithread để server có thể giao tiếp được với nhiều client cùng lúc. Slide: số….\n\n[PAGE 20]\nBài tập 3 Viết chương trình minh hoạt giao thức FTP cho phép hai máy gửi tập tin cho nhau sử dụng UDP Socket. Slide: số….",
    "source_id": "temp_8bf905e3-6536-4d57-90b7-1f3ecc4e3a7e_5. Lập trình với giao thức UDP (1).pdf",
    "title": "temp_8bf905e3-6536-4d57-90b7-1f3ecc4e3a7e_5. Lập trình với giao thức UDP (1)",
    "section": "",
    "section_level": 0,
    "page": 17,
    "course": "Unknown",
    "semester": "Unknown",
    "language": "vietnamese",
    "doc_type": "pdf",
    "keywords": [
      "client",
      "server",
      "buff",
      "giao",
      "slide",
      "message",
      "length",
      "datagrampacket",
      "page",
      "system"
    ],
    "hash": "0dfb69b6d8025b18e2d0436fae6f8eb7",
    "created_at": "2025-09-20T12:48:04.324273",
    "start_char": 4131,
    "end_char": 5692,
    "chunk_index": 1,
    "point_id": "83ca6fb2-40a2-4bd0-b57a-1c3cabb46313",
    "vector_index": 1
  },
  {
    "chunk_id": "fccad47e-f6b7-4810-ac4b-d29d8ca76aab",
    "content": "[PAGE 1]\nCHƯƠNG 6: Tuần tự hoá đối tượng và ứng dụng trong lập trình mạng Giảng viên: Ths. Phạm Văn Tiệp Slide: số….\n\n[PAGE 2]\nNội dung bài học ▪ Tuần tự hoá đối tượng ▪ Truyền các đối tượng thông qua Socket ▪ Truyền các đối tượng thông qua giao thức UDP SlideS:li dseố: …số .2\n\n[PAGE 3]\nTuần tự hoá đối tượng Slide: số….\n\n[PAGE 4]\nTuần tự hoá đối tượng ▪ Tuần tự hoá đối tượng còn được gọi là “serialization” ▪ Serialization là quá trình chuyển đổi một đối tượng thành dạng dữ liệu có thể truyền qua mạng ▪ Deserialization là quá trình chuyển đổi dữ liệu đã được tuần tự hoá thành đối tượng ▪ Để thực hiện Serialization một đối tượng thì đối tượng đó cần được implements từ Serialization Interface ▪ ObjectOutputStream dùng để ghi đối tượng vào luồng ▪ ObjectInputStream được sử dụng để đọc đối tượng từ luồng Slide: số….\n\n[PAGE 5]\nVí dụ public class Car implements Serializable { private String id; private String name; public Car(String id, String name) { super(); this.id = id; this.name = name; } public String getId() { return id; } public String getName() { return name; } } Slide: số….\n\n[PAGE 6]\nVí dụ public class SerializationExample { public static void main(String[] args) { try (ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(\"data.ser\"))) { Car obj = new Car(\"1\", \"Honda\"); outputStream.writeObject(obj); } catch (IOException e) { e.printStackTrace(); } try (ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(\"data.ser\"))) { Car obj = (Car) inputStream.readObject(); System.out.println(\"Car: \"+obj.getName()); } catch (IOException | ClassNotFoundException e) { e.printStackTrace(); } } } Slide: số….\n\n[PAGE 7]\nTruyền đối tượng thông qua Socket Slide: số….\n\n[PAGE 8]\nTruyền các đối tượng qua Socket Sử dụng luồng ObjectOutputStream để gửi đối tượng qua socket ▪ Phương thức writeObject(Object o) o Sử dụng luồng ObjectInputStream để nhận đối tượng từ socket ▪ Phương thức Object readObject() o Đối tượng truyền trên socket phải thuộc lớp được triển khai từ giao diện ▪ Serializable Các lớp của Java định nghĩa đều triển khai từ Serializable o Slide: số….\n\n[PAGE 9]\nTruyền các đối tượng qua Socket public class Student implements Serializable { private String id; private String name; public Student(String id, String name) { super(); this.id = id; this.name = name; } public String getId() { return id; } public String getName() { return name; } } Slide: số….\n\n[PAGE 10]\nTruyền các đối tượng qua Socket public class Server { private static void communicate(Socket connSocket){ try(ObjectInputStream in = new ObjectInputStream(connSocket.getInputStream())){ Student student; try{ while((student = (Student) in.readObject()) != null) System.out.println(\"Received: \" + student.getName()); }catch (ClassNotFoundException e) { System.out.println(\"Invalid data from client!\"); }catch(IOException e){ System.out.println(\"Client stopped sending data!\"); } }catch(IOException e){ System.out.println(\"Cannot communicate to client!\"); } } Slide: số….\n\n[PAGE 11]\nTruyền các đối tượng qua Socket public static void main(String[] args) { try (ServerSocket liServerSocket = new ServerSocket(5000)) { System.out.println(\"Server started!\"); while (true) { Socket connSocket = liServerSocket.accept(); communicate(connSocket); } } catch (IOException e) { System.out.println(\"Cannot start server on port 5000!\"); } } } Slide: số….\n\n[PAGE 12]\nTruyền các đối tượng qua Socket public class Client { public static void main(String[] args) { try (Socket clientSocket = new Socket(\"localhost\", 5000); BufferedReader useReader = new BufferedReader(new InputStreamReader(System.in)); ObjectOutputStream outputStream = new ObjectOutputStream(clientSocket.getOutputStream())) { while(true) { String id; System.out.print(\"Student's ID: \"); id = useReader.readLine(); if(id.length() == 0) { System.out.println(\"Stopped sending data to server!\"); break; } Slide: số….\n\n[PAGE 13]\nTruyền các đối tượng qua Socket String name; System.out.print(\"Student's name: \"); name = useReader.readLine(); Student student = new Student(id, name); outputStream.writeObject(student); outputStream.flush(); } clientSocket.close(); } catch (IOException e) { System.out.println(\"Cannot connect to server!\"); } } } Slide: số….\n\n[PAGE 14]\nTruyền đối tượng thông qua UDP Slide: số….\n\n[PAGE 15]\nTruyền các đối tượng qua UDP Sử dụng luồng ByteArrrayOutputStream để chuyển object thành mảng byte ▪ Phương thức Object.toByteArray() o Sử dụng luồng ByteArrrayInputStream để chuyển mảng byte thành object ▪ Phương thức readObject() o Sử dụng luồng ObjectOutputStream để ghi đối tượng vào luồng ▪ Phương thức writeObject(Object o) o Sử dụng luồng ObjectInputStream để đọc đối tượng từ luồng ▪ Phương thức Object.readObject() o Đối tượng truyền trên socket phải thuộc lớp được triển khai từ giao diện ▪ Serializable Các lớp của Java định nghĩa đều triển khai từ Serializable o Slide: số….\n\n[PAGE 16]\nTruyền các đối tượng qua UDP public class Message implements Serializable { private String id; private String message; public Message(String id, String message) { super(); this.id = id; this.message = message; } public String getId() { return id; } public String getMessage() { return message; } } Slide: số….\n\n[PAGE 17]\nTruyền các đối tượng qua UDP public class Server { static DatagramSocket serverSocket = null; static ObjectInputStream ois = null; static ObjectOutputStream oos = null; static byte[]",
    "source_id": "temp_1ad1bf63-052b-4e0a-a76e-a685a667093b_6. Tuần tự hoá đối tượng và ứng dụng trong lập trình mạng (3).pdf",
    "title": "temp_1ad1bf63-052b-4e0a-a76e-a685a667093b_6. Tuần tự hoá đối tượng và ứng dụng trong lập trình mạng (3)",
    "section": "",
    "section_level": 0,
    "page": 1,
    "course": "Unknown",
    "semester": "Unknown",
    "language": "english",
    "doc_type": "pdf",
    "keywords": [
      "string",
      "public",
      "page",
      "socket",
      "slide",
      "name",
      "student",
      "system",
      "println",
      "objectoutputstream"
    ],
    "hash": "f75c3ad79e4aaeb75399a3933034db66",
    "created_at": "2025-09-20T12:48:04.874518",
    "start_char": 2,
    "end_char": 5410,
    "chunk_index": 0,
    "point_id": "75fabc7d-bfd1-4043-82f5-34b56651e208",
    "vector_index": 2
  },
  {
    "chunk_id": "fe3c6688-df9a-4f86-844a-3855c9e5cd5d",
    "content": "khai từ giao diện ▪ Serializable Các lớp của Java định nghĩa đều triển khai từ Serializable o Slide: số….\n\n[PAGE 16]\nTruyền các đối tượng qua UDP public class Message implements Serializable { private String id; private String message; public Message(String id, String message) { super(); this.id = id; this.message = message; } public String getId() { return id; } public String getMessage() { return message; } } Slide: số….\n\n[PAGE 17]\nTruyền các đối tượng qua UDP public class Server { static DatagramSocket serverSocket = null; static ObjectInputStream ois = null; static ObjectOutputStream oos = null; static byte[] buffIn = new byte[50000]; static byte[] buffOut = new byte[50000]; static byte[] data = null; public static void main(String[] args) { try { serverSocket = new DatagramSocket(5051); System.out.println(\"Server Stared!\"); while (true) { try { DatagramPacket in = new DatagramPacket(buffIn, buffIn.length); Slide: số….\n\n[PAGE 18]\nTruyền các đối tượng qua UDP serverSocket.receive(in); data = in.getData(); ois = new ObjectInputStream(new ByteArrayInputStream(data)); Message message = (Message) ois.readObject(); System.out.println(\"Client say: \"+ message.getMessage()); Message messageOut = new Message(message.getId(), message.getMessage().toUpperCase()); ByteArrayOutputStream os = new ByteArrayOutputStream(); oos = new ObjectOutputStream(os); oos.writeObject(messageOut); buffOut = os.toByteArray(); Slide: số….\n\n[PAGE 19]\nTruyền các đối tượng qua UDP DatagramPacket out = new DatagramPacket(buffOut, buffOut.length, in.getAddress(), in.getPort()); serverSocket.send(out); } catch (IOException e) { System.out.println(\"Cannot communicate to client!\"); } catch (ClassNotFoundException e) { System.out.println(\"Can not convert data to message\"); } } } catch (IOException e) { System.out.println(\"Cannot start server!\"); } } } Slide: số….\n\n[PAGE 20]\nTruyền các đối tượng qua UDP public class Client { static byte[] buffIn = new byte[50000]; static byte[] buffOut = new byte[50000]; static ObjectInputStream ois = null; static ObjectOutputStream oos = null; static DatagramSocket clientSocket = null; static byte[] data = null; public static void main(String[] args) { try { clientSocket = new DatagramSocket(5052); while (true) { try { InetAddress serverAddress = InetAddress.getByName(\"localhost\"); Slide: số….\n\n[PAGE 21]\nTruyền các đối tượng qua UDP System.out.print(\"Nhap id: \"); String id = new Scanner(System.in).nextLine(); System.out.print(\"Nhap message: \"); String message = new Scanner(System.in).nextLine(); Message messageOut = new Message(id, message); ByteArrayOutputStream os = new ByteArrayOutputStream(); oos = new ObjectOutputStream(os); oos.writeObject(messageOut); buffOut = os.toByteArray(); DatagramPacket out = new DatagramPacket(buffOut, buffOut.length, serverAddress, 5051); clientSocket.send(out); Slide: số….\n\n[PAGE 22]\nTruyền các đối tượng qua UDP DatagramPacket in = new DatagramPacket(buffIn, buffIn.length); clientSocket.receive(in); data = in.getData(); ois = new ObjectInputStream(new ByteArrayInputStream(data)); Message messageIn = (Message) ois.readObject(); System.out.println(\"Server send: \" + messageIn.getMessage()); } catch (IOException e) { System.out.println(\"Cannot communicate to server!\"); } catch (ClassNotFoundException e) { System.out.println(\"Can not convert data to Message!\"); } } Slide: số….\n\n[PAGE 23]\nTruyền các đối tượng qua UDP } catch (SocketException e) { System.out.println(\"Cannot start client!\"); } } } Slide: số….",
    "source_id": "temp_1ad1bf63-052b-4e0a-a76e-a685a667093b_6. Tuần tự hoá đối tượng và ứng dụng trong lập trình mạng (3).pdf",
    "title": "temp_1ad1bf63-052b-4e0a-a76e-a685a667093b_6. Tuần tự hoá đối tượng và ứng dụng trong lập trình mạng (3)",
    "section": "",
    "section_level": 0,
    "page": 16,
    "course": "Unknown",
    "semester": "Unknown",
    "language": "english",
    "doc_type": "pdf",
    "keywords": [
      "message",
      "static",
      "system",
      "string",
      "byte",
      "slide",
      "println",
      "page",
      "public",
      "null"
    ],
    "hash": "504b41454a34a1b720754870c7db7866",
    "created_at": "2025-09-20T12:48:04.875720",
    "start_char": 4790,
    "end_char": 8285,
    "chunk_index": 1,
    "point_id": "386d869b-4de5-42c3-9314-b0d12db54967",
    "vector_index": 3
  },
  {
    "chunk_id": "dcb1a616-0ed9-42b5-b29d-62c435ea49d0",
    "content": "[PAGE 1]\nCHƯƠNG 7: Kỹ thuật lập trình phân tán RMI Giảng viên: Ths. Phạm Văn Tiệp Slide: số….\n\n[PAGE 2]\nNội dung bài học ▪ Tổng quan ▪ Mục đích của RMI ▪ Một số thuật ngữ ▪ Các lớp trung gian Stub và Skeleton ▪ Cơ chế hoạt động của RMI ▪ Cài đặt chương trình ▪ Các lớp và interface trong gói java.rmi ▪ Các lớp và các interface trong gói java.rmi.registry ▪ Các lớp và interface trong gói java.rmi.server SlideS:li dseố: …số .2\n\n[PAGE 3]\nTổng quan Slide: số….\n\n[PAGE 4]\nGiới thiệu Local method Invocation: mã lệnh của hàm (hay thủ tục) được nạp ▪ thẳng vào bộ nhớ và thực thi ngay trên máy cục bộ → Muốn nạp nội dung hàm hay đối tượng ở 1 máy nào đó gọi chúng từ một máy khác? Remote Method Invocation (RMI): là cách thức giao tiếp giữa các ▪ đối tượng Java có mã lệnh cài đặt nằm trên máy khác nhau có thể gọi lẫn nhau. Slide: số….\n\n[PAGE 5]\nVấn đề phát sinh Việc gọi phương thức của đối tượng từ xa luôn phức tạp hơn gọi phương thức cục ▪ bộ: Việc tham chiếu đến biến, địa chỉ của đối tượng khác nhau ở các máy khác nhau o Các tham số truyền cho phương thức của đối tượng ở xa phải được đóng gói và o chuyển qua mạng đến phương thức thực sự. (local-stack) Lời gọi phương thức từ xa phải thông qua mạng và có thể bị ngắt ngang do o mạng gặp sự cố Phụ thuộc vào kết nối mạng ▪ Slide: số….\n\n[PAGE 6]\nGiải pháp ▪ Đối tượng trên hai máy khác nhau không gọi trực tiếp mà thông qua lớp trung gian. ▪ Lớp trung gian tồn tại ở cả hai phía Client và Server. o Lớp ở máy Client gọi là Stub, o Lớp ở máy Server gọi là Skel (Skeletion) ▪ Lớp trung gian Stub sẽ biết cách thông báo lỗi khi có các sự cố về mạng cho Client Slide: số….\n\n[PAGE 7]\nLớp trung gian Stub và Skeletion Computer A Computer B b A2 u l e B1 t k S S _ A1 _ 1 1 B B C1_Stub Computer C l e k S _ C1 1 C Slide: số….\n\n[PAGE 8]\nLớp trung gian Stub và Skeletion Trình biên dịch Java (rmic.exe) sẽ tạo ra 2 lớp trung gian: ▪ Lớp Stub (lớp móc): chuyển về cho client o Lớp Skeleton (lớp nối): Phía Server o Stub và Skeletion sẽ giúp các đối tượng ở xa giao dịch với nhau? ▪ Đối tượng trên máy Server cần cung cấp một interface tương ứng với các o phương thức của nó (Server Object) cho phép đối tượng Client gọi nó trên máy Client dễ dàng. Đối tượng client sẽ luôn nghĩ rằng nó đang hoạt động trực tiếp với đối tượng o server trên máy cục bộ. Slide: số….\n\n[PAGE 9]\nKiến trúc của RMI Slide: số….\n\n[PAGE 10]\nQuá trình hoạt động của RMI bind RMI Server     Remote Machine (Server) Registry Skeleton  return   call lookup Stub   Local Machine (Client) RMI Client  Slide: số….\n\n[PAGE 11]\nQuá trình hoạt động của RMI B1: RMI-server đăng ký tên của đối tượng với bộ quản lý Registry. B2: Bộ quản lý Registry trả về tham chiếu đến đối tượng ở xa (RMI Server) thông qua lớp giao diện B3-4: RMI-client liên lạc với bộ Registry để lấy về tham chiếu đến đối tượng trên Server. Các quá trình đăng ký và truy tìm tên đối tượng được Java quản lý bằng các hàm giao diện API JNDI B5-7: Client sẽ gọi các phương thức của đối tượng trên Server Khi một phương thức được gọi, sẽ được chuyển tiếp đến lớp trung gian Stub, rồi gọi đến lớp Skeleton (hđ Stub). B8-10: Lớp Skeleton sẽ trực tiếp yêu cầu đối tượng thực thi phương thức và trả kết quả cho Client (hđ Skeletion) Slide: số….\n\n[PAGE 12]\nTrình (bộ quản lý) đăng ký Registry Là một chương trình dịch vụ chạy ở hậu trường (rmiregistry.exe), thực hiện mở ổ ▪ cắm socket và lắng nghe các yêu cầu gửi đến cổng mặc định 1099, có thể chỉ định một cổng khác với cổng 1099. Ví dụ: C:\\j2sdk1.4.0\\bin\\ rmiregistry.exe 9999 Đóng vai trò như là một DNS nhỏ cho các đối tượng từ xa thực hiện tìm kiếm dịch ▪ vụ. Slide: số….\n\n[PAGE 13]\nHoạt động của Stub, Skeleton ❖ Client gọi một phương thức từ xa, lời gọi này được chuyển tiếp đến Stub. ❖ Stub có nhiệm vụ gửi tiếp lời yêu cầu này đến Skeleton phía server bằng",
    "source_id": "temp_236f866b-c664-4eec-be97-a2a9536c0d57_7. Kỹ thuật lập trình phân tán RMI.pdf",
    "title": "temp_236f866b-c664-4eec-be97-a2a9536c0d57_7. Kỹ thuật lập trình phân tán RMI",
    "section": "",
    "section_level": 0,
    "page": 1,
    "course": "Unknown",
    "semester": "Unknown",
    "language": "vietnamese",
    "doc_type": "pdf",
    "keywords": [
      "server",
      "page",
      "stub",
      "client",
      "slide",
      "trung",
      "gian",
      "skeleton",
      "java",
      "registry"
    ],
    "hash": "57c32ae9fbb3efbf9968d513ccf25f99",
    "created_at": "2025-09-20T12:48:05.891031",
    "start_char": 2,
    "end_char": 3795,
    "chunk_index": 0,
    "point_id": "88c44472-2fd3-4f3e-85d6-b107b0f80b32",
    "vector_index": 4
  },
  {
    "chunk_id": "f7ce03e4-7a9f-49b2-84e2-824657896611",
    "content": "ở hậu trường (rmiregistry.exe), thực hiện mở ổ ▪ cắm socket và lắng nghe các yêu cầu gửi đến cổng mặc định 1099, có thể chỉ định một cổng khác với cổng 1099. Ví dụ: C:\\j2sdk1.4.0\\bin\\ rmiregistry.exe 9999 Đóng vai trò như là một DNS nhỏ cho các đối tượng từ xa thực hiện tìm kiếm dịch ▪ vụ. Slide: số….\n\n[PAGE 13]\nHoạt động của Stub, Skeleton ❖ Client gọi một phương thức từ xa, lời gọi này được chuyển tiếp đến Stub. ❖ Stub có nhiệm vụ gửi tiếp lời yêu cầu này đến Skeleton phía server bằng cách ▪ Stub mở một socket đến server, ▪ Đóng gói các tham số: • Gói nhận dạng đối tượng từ xa • Gói phương pháp nhận dạng ▪ Truyền luồng dữ liệu này đến Skeleton. ❖ Skeleton chứa đựng một phương thức nhận các lời yêu cầu từ xa, ▪ Mở gói tham số, ▪ Gọi hàm thực sự trên server để tính toán ▪ Trả kết quả về Stub phía client. Slide: số….\n\n[PAGE 14]\nRMI trong JAVA Các lớp và các interface trong gói java.rmi ▪ Interface Remote o Lớp Naming o RemoteObject class o RemoteServer class o UnicastRemoteObject class o Interface Registry o Slide: số….\n\n[PAGE 15]\nLớp Naming Lớp java.rmi.Naming truyền tin trực tiếp với một trình đăng ký đang chạy trên ▪ server để ánh xạ các URL rmi://hostname/objectname thành các đối tượng từ xa cụ thể trên host xác định: rmi: là giao thức dùng để đăng kí. o hostname: và port của Server nơi bộ Registry đang chạy. o objectname: là tên tự đặt, phía client sẽ dựa vào tên này để truy tìm tham chiếu o đến đối tượng cần dùng. URL rmi vs. URL http. ▪ Slide: số….\n\n[PAGE 16]\nNaming class - methods Lớp Naming cung cấp các phương thức sau: ▪ public static String[] list(String url) throws RemotException o trả về một mảng các xâu ký tự, mỗi xâu là một URL đã được gắn với một tham chiếu. url là URL của trình đăng ký Naming. public static Remote lookup(String url) throws RemotException, o NotBoundException, AccessException, MalformedURLException Client lookup để tìm kiếm một đối tượng từ xa gắn liền với tên đối tượng. NotBoundException: server ở xa không nhận ra tên của nó. Slide: số….\n\n[PAGE 17]\nNaming class - methods Public static void bind(String url, Remote object) throws RemotException, o AlreadyBoundException, MalformedURLException, AccessException để liên kết một tên với một đối tượng ở xa. Nếu thành công thì client có thể tìm kiếm đối tượng stub từ trình đăng ký. Có rất nhiều tình huống có thể xảy ra khi gán tên. o MalformedURLException: url không đúng cú pháp. • RemoteException: không thể liên lạc được với trình đăng ký • AccessException: client không được phép gán các đối tượng trong trình đăng • ký. AlreadyBoundException: nếu đối tượng URL đã gắn với một đối tượng cục bộ • Slide: số….\n\n[PAGE 18]\nNaming class - methods public static void rebind(String url, Remote obj)throws RemoteException, o AccessException, MalformedURLException Phương thức này giống như phương thức bind() ngoại trừ việc là nó gán URL cho đối tượng ngay cả khi URL đã được gán. Slide: số….\n\n[PAGE 19]\nGiao diện Remote Giao diện này không khai báo bất kỳ phương thức nào. ▪ Khai báo một đối tượng được truy xuất từ xa: ▪ extends Implement UnicastRemoteServer Remote Object Slide: số….\n\n[PAGE 20]\nRemoteObject class ❖ RemoteObject class ❖ Các đối tượng từ xa là thể hiện của các lớp con của RemoteObject. ❖ RemoteServer class ❖ con của lớp RemoteObject; ❖ cha của lớp UnicastRemoteObject. ❖ UnicastRemoteObject class ❖ là một lớp con cụ thể của lớp RemoteServer. ❖ Để tạo ra một đối tượng ở xa: ❖ ta phải thừa kế lớp UnicastRemoteServer ❖ khai báo lớp này thực thi giao tiếp Remote ❖ Phương thức exportObject(Object): làm cho máy ảo Java nhận diện được đối tượng Object. Slide: số….\n\n[PAGE 21]\nGiao diện Registry Cho phép các client tìm kiếm các đối tượng ở xa trên một server theo tên. ▪ Các phương thức ▪ Bind() để gán một tên với một đối tượng từ xa cụ thể o List() liệt kê tất cả các tên đã được đăng ký với trình đăng ký o Lookup() tìm một đối tượng từ xa cụ thể với một URL cho trước gắn với nó o Rebind() gán một tên với một đối tượng ở xa khác o Unbind() loại bỏ một tên đã được gán cho một đối tượng ở xa trong trình đăng o ký Registry.REGISTRY_PORT là cổng mặc định để lắng nghe các các yêu cầu. o Giá trị mặc định là 1099. Slide: số….\n\n[PAGE 22]\nCác bước thiết kế và cài đặt",
    "source_id": "temp_236f866b-c664-4eec-be97-a2a9536c0d57_7. Kỹ thuật lập trình phân tán RMI.pdf",
    "title": "temp_236f866b-c664-4eec-be97-a2a9536c0d57_7. Kỹ thuật lập trình phân tán RMI",
    "section": "",
    "section_level": 0,
    "page": 13,
    "course": "Unknown",
    "semester": "Unknown",
    "language": "vietnamese",
    "doc_type": "pdf",
    "keywords": [
      "slide",
      "page",
      "class",
      "naming",
      "client",
      "server",
      "remote",
      "stub",
      "remoteobject",
      "giao"
    ],
    "hash": "552190ac47d309da32840fbaf626de13",
    "created_at": "2025-09-20T12:48:05.891894",
    "start_char": 3304,
    "end_char": 7501,
    "chunk_index": 1,
    "point_id": "a5a15d8d-2574-492b-84cd-d3698ff40a73",
    "vector_index": 5
  },
  {
    "chunk_id": "594cc386-751f-4dc8-b42c-b2b6822d9bdf",
    "content": "từ xa cụ thể o List() liệt kê tất cả các tên đã được đăng ký với trình đăng ký o Lookup() tìm một đối tượng từ xa cụ thể với một URL cho trước gắn với nó o Rebind() gán một tên với một đối tượng ở xa khác o Unbind() loại bỏ một tên đã được gán cho một đối tượng ở xa trong trình đăng o ký Registry.REGISTRY_PORT là cổng mặc định để lắng nghe các các yêu cầu. o Giá trị mặc định là 1099. Slide: số….\n\n[PAGE 22]\nCác bước thiết kế và cài đặt RMI 1. Đặc tả một giao diện từ xa (remote interface) trên server. 2. Hiện thực giao diện từ xa (remote interface) để Xây dựng một đối tượng từ xa (remote object) . 3. Xây dựng chương trình phía Server 4. Xây dựng chương trình phía Client. Slide: số….\n\n[PAGE 23]\nCài đặt chương trình cộng 2 số nguyên Triệu gọi đối tượng RMI giữa trình khách và đối tượng chủ ở xa Slide: số….\n\n[PAGE 24]\n1. Đặc tả một Remote Interface (at Srv) Các đối tượng trong Remote Inteface phải có khả năng giao tiếp với các đối tượng o ở xa (Kế thừa Remote class) Các phương thức phải có khả năng phát ra ngoại lệ RemoteException. o // Calculator.java import java.rmi.*; public interface Calculator extends Remote { public int addNum(int x,int y) throws RemoteException; } Biên dịch Slide: số….\n\n[PAGE 25]\n2. Hiện thực Remote Interface Từ Remote Interface đã định nghĩa, đối tượng thực sự phải được cài đặt: /* CalculatorImpl.java*/ import java.rmi.*; // extends UnicastRemoteObject public class CalculatorImpl implements Calculator { public int addNum(int x,int y) throws RemoteException { System.out.println(\"Client request to calculate\"); return (x+y); } } Biên dịch Slide: số….\n\n[PAGE 26]\n3. Xây dựng chương trình trên Server /* CalServer.java*/ public class CalculatorServer{ public static void main(String[] args) throws AlreadyBoundException { try{ //tao doi tuong Calculator thuc su CalculatorImpl c= new CalculatorImpl(); System.out.println(\"Exporting Calculator ! \"); //thông báo sự hiện diện c là đối tượng có khả năng Remote cho JVM UnicastRemoteObject.exportObject (c); //đăng ky doi tuong với trình quản lý rmi Naming.bind(\"rmi://localhost/Van\",c); System.out.println(\"Register Calculator!\"); } catch(Exception e) { System.out.println(e); } } } Biên dịch Slide: số….\n\n[PAGE 27]\n4. Xây dựng chương trình trên Client Chương trình phía bên máy client có khả năng gọi và sử dụng đối tượng Cal trên máy server: /* CalculatorClient.java*/ import java.rmi.*; public class CalculatorClient { public static void main(String[] args){ try{ System.out.println(\"Finding Object … \"); // tìm đối tượng cần truy xuất theo tên -> tường minh Calculator c= (Calculator)Naming.lookup (\"rmi://localhost/Van\"); // goi phuong thuc cua doi tuong System.out.println(c.addNum(5,10)); } catch(Exception e) { System.out.println(e); } } } Biên dịch Slide: số….\n\n[PAGE 28]\nTRUYỀN THAM SỐ TRONG RMI Tham số phải: kiểu cơ sở, serializable hoặc implements Remote interface Slide: số….\n\n[PAGE 29]\nimport java.rmi.*; public interface RObject extends Remote { // This parameter is primitive. void primitiveArg(int num) throws RemoteException; // This parameter implements Serializable. void byValueArg(Integer num) throws RemoteException; // This parameter implements Remote. void byRefArg(ArgObject arg) throws RemoteException; } public interface ArgObject extends Remote { int aMethod() throws RemoteException; } Slide: số….\n\n[PAGE 30]\ntry { // Look up the remote object RObject robj = (RObject) Naming.lookup(\"//localhost/RObjectServer\"); // Pass a primitive value as argument robj.primitiveArg(1998); // Pass a serializable object as argument robj.byValueArg(new Integer(9)); // Pass a Remote object as argument robj.byRefArg(new ArgObjectImpl()); } catch (MalformedURLException e) { } catch (UnknownHostException e) { } catch (NotBoundException e) { } catch (RemoteException e) { } Slide: số….\n\n[PAGE 31]\nBài tập Bài tập 1: Sử dụng RMI viết chương trình server tạo ra đối tượng thư viện cho phép cộng hai phân số. Một chương trình client tạo ra 2 đối tượng phân số và gọi từ xa đối tượng thư viện ở server để cộng hai phân số này. Bài tập 2: Viết chương trình liệt kê các số nguyên tố từ 1 đến N, với N là một số nguyên dương, sử dụng kỹ thuật lập trình RMI. Phương thức kiểm tra số nguyên tố được triệu gọi từ xa. Bài tập 3: Viết chương trình xử lý xâu ký tự sử dụng kỹ thuật lập trình RMI. Các chức năng xử lý xâu gồm có: chuyển thành xâu in thường, chuyển thành xâu in hoa, chuẩn hóa xâu (xóa các khoảng trắng thừa), đếm số từ của xâu. Các phương thức xử lý xâu được triệu gọi từ xa. Slide: số….",
    "source_id": "temp_236f866b-c664-4eec-be97-a2a9536c0d57_7. Kỹ thuật lập trình phân tán RMI.pdf",
    "title": "temp_236f866b-c664-4eec-be97-a2a9536c0d57_7. Kỹ thuật lập trình phân tán RMI",
    "section": "",
    "section_level": 0,
    "page": 22,
    "course": "Unknown",
    "semester": "Unknown",
    "language": "vietnamese",
    "doc_type": "pdf",
    "keywords": [
      "remote",
      "slide",
      "page",
      "public",
      "interface",
      "remoteexception",
      "calculator",
      "java",
      "throws",
      "system"
    ],
    "hash": "d46ae24ce3c839a7773bef397e4d7a51",
    "created_at": "2025-09-20T12:48:05.892765",
    "start_char": 7063,
    "end_char": 11556,
    "chunk_index": 2,
    "point_id": "d90c2027-edcb-44cf-89bf-e85bc9a8591d",
    "vector_index": 6
  },
  {
    "chunk_id": "491512ed-308f-4f79-ac2e-392d7c2515d3",
    "content": "tự sử dụng kỹ thuật lập trình RMI. Các chức năng xử lý xâu gồm có: chuyển thành xâu in thường, chuyển thành xâu in hoa, chuẩn hóa xâu (xóa các khoảng trắng thừa), đếm số từ của xâu. Các phương thức xử lý xâu được triệu gọi từ xa. Slide: số….",
    "source_id": "temp_236f866b-c664-4eec-be97-a2a9536c0d57_7. Kỹ thuật lập trình phân tán RMI.pdf",
    "title": "temp_236f866b-c664-4eec-be97-a2a9536c0d57_7. Kỹ thuật lập trình phân tán RMI",
    "section": "",
    "section_level": 0,
    "page": 31,
    "course": "Unknown",
    "semester": "Unknown",
    "language": "vietnamese",
    "doc_type": "pdf",
    "keywords": [
      "slide"
    ],
    "hash": "096b2ad472a29a36891eaffee821393f",
    "created_at": "2025-09-20T12:48:05.892880",
    "start_char": 11315,
    "end_char": 11556,
    "chunk_index": 3,
    "point_id": "c0dca54c-e365-444e-b767-6a958af07c1e",
    "vector_index": 7
  },
  {
    "chunk_id": "84b0cca8-8f87-48ee-88af-324f29164f02",
    "content": "[PAGE 1]\nBỘ GIÁO DỤC VÀ ĐÀO TẠO CỘNG HÒA XÃ HỘI CHỦ NGHĨA VIỆT NAM TRƯỜNG ĐẠI HỌC ĐẠI NAM Độc lập – Tự do – Hạnh phúc ĐỀ CƯƠNG CHI TIẾT HỌC PHẦN LẬP TRÌNH MẠNG (Ban hành kèm theo Quyết định số: …………./QĐ-ĐN ngày tháng năm 2022 của Hiệu trưởng Trường Đại học Đại Nam) 1. THÔNG TIN TỔNG QUÁT (GENERAL INFORMATION) - Tên học phần (tiếng Việt): Lập trình mạng - Tên học phần (tiếng Anh): Network Programming - Mã số học phần: 077CQ2bLTM - Thuộc khối kiến thức: Giáo dục chuyên nghiệp - Số tín chỉ: 03 tín chỉ (3,2,1) + Số tiết lý thuyết: 30 + Số tiết thực hành: 15 + Số tiết tự học: 90 - Các học phần tiên quyết (nếu có): Lập trình hướng đối tượng - Các học phần học song song (nếu có): - Đơn vị phụ trách: Khoa Công nghệ thông tin 2. THÔNG TIN GIẢNG VIÊN Chức TT Họ và tên danh, Liên hệ Đơn vị công tác học vị Trường Đại học Đại 1 Phạm Văn Tiệp Thạc sĩ tieppv@dainam.edu.vn Nam Trường Đại học Đại 2 Trần Thu Trang Thạc sĩ trangtt@dainam.edu.vn Nam 3. MÔ TẢ HỌC PHẦN (COURSE DESCRIPTIONS) Học phần trang bị cho người học những kiến thức nền tảng của lập trình mạng và các kỹ năng cần thiết để thiết kế và cài đặt các ứng dụng mạng và các chuẩn ở mức ứng dụng dựa trên mô hình Client/Server, có sử dụng các giao tiếp chương trình dựa trên Sockets. Kết thúc học phần, sinh viên có thể viết các chương trình ứng dụng mạng với giao thức tầng ứng dụng tự thiết kế.\n\n[PAGE 2]\n4. MỤC TIÊU HỌC PHẦN (COURSE GOALS) 4.1. Mục tiêu chung Sau khi hoàn tất học phần, sinh viên có thể: Hiểu cách thức truyền nhận dữ liệu qua mạng; Nắm vững cách thức sử dụng lớp Socket và các lớp hỗ trợ lập trình hệ thống mạng trong ngôn ngữ Java; Nắm vững qui trình thiết kế và xây dựng ứng dụng mạng; Sử dụng thành thạo kỹ thuật lập trình Java để viết các ứng dụng mạng trong thực tế. 4.2. Mục tiêu cụ thể 4.2.1. Mục tiêu về kiến thức MTKTHP01. Hiểu rõ các mô hình, ý nghĩa của giao thức ứng dụng mạng MTKTHP02. Nắm vững các kiến thức cơ bản về lập trình mạng và quy trình phát triển ứng dụng mạng. 4.2.2. Mục tiêu về kỹ năng MTKNHP01. Kỹ năng phát triển ứng dụng mạng theo giao thức định nghĩa sẵn dựa trên giao diện lập trình socket và các thư viện hỗ trợ đã được giới thiệu. MTKNHP02. Kỹ năng lập trình ứng dụng mạng với ngôn ngữ lập trình phổ biến Java. 4.2.3. Mục tiêu về năng lực tự chủ và trách nhiệm MTNLHP01. Chia sẻ kiến thức lý thuyết và thực hành với các thành viên trong lớp, để không ngừng nâng cao hiểu biết về kỹ thuật lập trình mạng. MTNLHP02. Sẵn sàng tham gia vào các vị trí việc làm liên quan đến lĩnh vực lập trình mạng. Bảng 1: Ma trận mục tiêu chương trình đào tạo và mục tiêu học phần Mục tiêu CTĐT 1 2 1 2 1 2 T T N N L L Mục tiêu học phần K K K K N N T T T T T T M M M M M M 3 3 3 3 3 3 MTKTHP01 3 3 MTKTHP02 3 3 MTKNHP01 3 3 MTKNHP02 3 3 MTNLHP01 3 3\n\n[PAGE 3]\nMTNLHP02 3 3 5. CHUẨN ĐẦU RA HỌC PHẦN (COURSE LEARNING OUTCOMES) 5.1. Chuẩn đầu ra về kiến thức CĐRKTHP01: Hiểu được phương pháp luận lập trình socket. CĐRKTHP02: Vận dụng thiết kế xây dựng ứng dụng truyền tin trên mạng bằng ngôn ngữ lập trình Java. 5.2. Chuẩn đầu ra về kỹ năng CĐRKNHP01. Xây dựng được ứng dụng mạng có sử dụng các giao thức ở tầng ứng dụng hoặc giao thức mạng tự định nghĩa. 5.3. Chuẩn đầu ra về năng lực tự chủ và trách nhiệm CĐRNLHP01: Hợp tác một cách chủ động và tích cực với các thành viên khác trong việc ứng dụng lập trình mạng trong các bài toán thực tế. CĐRNLHP02: Chủ động cập nhật các kỹ thuật mới trong lĩnh vực lập trình mạng. CĐRNLHP03: Tổng hợp được các kỹ năng trong lập trình mạng. Bảng 2: Ma trận mục tiêu học phần và chuẩn đầu ra học phần Chuẩn đầu ra học phần Mục tiêu học phần KT01 KT02 KN01 NL01 NL2 NL3 KT01 3 3 KT02 3 3 KN01 3 3 KN02 3 3 NL01 3 3 NL02 3 3 3\n\n[PAGE 4]\nBảng 3: Ma trận chuẩn đầu",
    "source_id": "temp_a9db6b81-d710-4dc6-b731-f081a77c346e_23_Lập trình mạng.pdf",
    "title": "temp_a9db6b81-d710-4dc6-b731-f081a77c346e_23_Lập trình mạng",
    "section": "",
    "section_level": 0,
    "page": 1,
    "course": "Unknown",
    "semester": "Unknown",
    "language": "vietnamese",
    "doc_type": "pdf",
    "keywords": [
      "giao",
      "trong",
      "page",
      "java",
      "course",
      "socket",
      "theo",
      "song",
      "dainam",
      "trang"
    ],
    "hash": "5d1333f9fc675fcbd256b6a48d41cf0b",
    "created_at": "2025-09-20T12:48:11.091418",
    "start_char": 2,
    "end_char": 3695,
    "chunk_index": 0,
    "point_id": "8c6ee172-41e9-4d43-a8ca-1819eeeb166e",
    "vector_index": 8
  },
  {
    "chunk_id": "f43cd28c-7bdd-4dbc-b7c7-d0f04d752a7e",
    "content": "với các thành viên khác trong việc ứng dụng lập trình mạng trong các bài toán thực tế. CĐRNLHP02: Chủ động cập nhật các kỹ thuật mới trong lĩnh vực lập trình mạng. CĐRNLHP03: Tổng hợp được các kỹ năng trong lập trình mạng. Bảng 2: Ma trận mục tiêu học phần và chuẩn đầu ra học phần Chuẩn đầu ra học phần Mục tiêu học phần KT01 KT02 KN01 NL01 NL2 NL3 KT01 3 3 KT02 3 3 KN01 3 3 KN02 3 3 NL01 3 3 NL02 3 3 3\n\n[PAGE 4]\nBảng 3: Ma trận chuẩn đầu ra chương trình đào tạo và chuẩn đầu ra học phần. CĐR CHƯƠNG TRÌNH ĐÀO TẠO 6 1 1 2 6 CĐR học phần T N L K K N R R R Đ Đ Đ C C C CĐRKTHP01 3 CĐRKTHP02 3 CĐRKNHP01 3 CĐRNLHP01 3 CĐRNLHP02 3 CĐRNLHP03 3 Bảng 4: Ma trận đáp ứng nội dung học phần với chuẩn đầu ra học phần Chuẩn đầu ra Nội dung học phần KT01 KT02 KN01 NL01 NL02 NL03 2 2 3 3 3 3 Chương 1. Giới thiệu các mô hình lập trình mạng 1.1. Tổng quan về lập trình mạng 1.1.1. Khái niệm 2 2 3 3 3 1.1.2. Ngôn ngữ lập trình 1.1.3. Thư viện hỗ trợ 1.2. Giao thức Internet 2 2 3 3 3 Chương 2. Lập trình đa luồng trong Java 2.1. Giới thiệu về luồng 2 2 3 3 3 (thread) 2.2. Vòng đời của một luồng 2 2 3 3 3 trong Java 2.3. Tạo và quản lý luồng 2 2 3 3 3 2.4. Ví dụ minh họa sử dụng 2 2 3 3 3 đa luồng\n\n[PAGE 5]\nChuẩn đầu ra Nội dung học phần KT01 KT02 KN01 NL01 NL02 NL03 2 2 3 3 3 3 2.5. Đồng bộ luồng 2 2 3 3 3 2.6. Tiến trình treo 2 2 3 3 3 Chương 3. Quản lý địa chỉ kết nối mạng với các lớp InetAddress, Url và UrlConnection 3.1. Lớp InetAddress 3.1.1. Tạo đối tượng InetAddress 3.1.2. Các phương thức 2 3 3 3 Getter 3.1.3. Các phương thức kiểm tra địa chỉ IP 3.2. Lớp Url 3.2.1. Tạo các đối tượng Url 3.2.2. Nhận thông tin từ một 2 3 3 3 URL 3.2.3. Phân tách một URL thành các phần thông tin 3.3. Lớp UrlConnection 2 3 3 3 Chương 4. Lập trình với giao thức TCP 4.1. Mô hình client/server 2 3 3 3 4.2. Mô hình truyền tin 2 3 3 3 socket 4.3. Lớp Socket 2 3 3 3 4.4. Lớp ServerSocket 2 3 3 3 4.5. Các bước xây dựng ứng 2 3 3 3 dụng Server 4.6. Các bước xây dựng ứng 2 3 3 3 dụng Client 4.8. Đa luồng trong lập trình 2 3 3 3 Socket 4.9. Một số ví dụ 2 2 3 3 3\n\n[PAGE 6]\nChuẩn đầu ra Nội dung học phần KT01 KT02 KN01 NL01 NL02 NL03 2 2 3 3 3 3 Chương 5. Lập trình với giao thức UDP 5.1. Tổng quan về giao thức 2 2 3 3 3 UDP 5.2. Lớp DatagramPacket 2 2 3 3 3 5.3. Lớp DatagramSocket 2 2 3 3 3 5.4. Nhận các gói tin 2 2 3 3 3 5.5. Gửi các gói tin 2 2 3 3 3 5.6. Một số ví dụ 2 2 3 3 3 Chương 6. Tuần tự hóa đối tượng và ứng dụng trong lập trình mạng 6.1. Tuần tự hóa đối tượng 2 2 3 3 3 6.2. Truyền các đối tượng 2 2 3 3 3 thông qua Socket 6.3. Truyền các đối tượng 2 2 3 3 3 thông qua giao thức UDP Chương 7. Kỹ thuật lập trình phân tán RMI 7.1. Tổng quan 2 2 3 3 3 7.2. Mục đích của RMI 2 2 3 3 3 7.3. Một số thuật ngữ 2 2 3 3 3 7.4. Các lớp trung gian Stub 2 3 3 3 và Skeleton 7.5. Cơ chế hoạt động của 2 2 3 3 3 RMI 7.6. Cài đặt chương trình 2 2 3 3 3 3 7.7. Các lớp và các interface 2 2 3 3 3 trong gói java.rmi 7.8. Các lớp và các interface 2 2 3 3 3 trong gói java.rmi.registry\n\n[PAGE 7]\nChuẩn đầu ra Nội dung học phần KT01 KT02 KN01 NL01 NL02 NL03 2 2 3 3 3 3 7.9. Các lớp và các interface 2 2 3 3 3 trong gói java.rmi.server 6. TÀI LIỆU THAM KHẢO 6.1. Tài liệu học tập: [1]. Nguyễn Phương Lan - Hoàng Đức Hải, Java Lập trình mạng, Nhà xuất bản Giáo dục, 2005. 6.2. Tài liệu tham khảo: [2] Elliotte",
    "source_id": "temp_a9db6b81-d710-4dc6-b731-f081a77c346e_23_Lập trình mạng.pdf",
    "title": "temp_a9db6b81-d710-4dc6-b731-f081a77c346e_23_Lập trình mạng",
    "section": "",
    "section_level": 0,
    "page": 4,
    "course": "Unknown",
    "semester": "Unknown",
    "language": "vietnamese",
    "doc_type": "pdf",
    "keywords": [
      "trong",
      "java",
      "dung",
      "giao",
      "page",
      "socket",
      "quan",
      "inetaddress",
      "server",
      "interface"
    ],
    "hash": "9a14461a336ce13897b9cf365e28e5a2",
    "created_at": "2025-09-20T12:48:11.092409",
    "start_char": 3254,
    "end_char": 6553,
    "chunk_index": 1,
    "point_id": "90d0b88c-88c9-425c-8b8c-5b6bf506f3de",
    "vector_index": 9
  },
  {
    "chunk_id": "ec67132b-c201-40b2-9748-e288d80009b5",
    "content": "3 3 7.7. Các lớp và các interface 2 2 3 3 3 trong gói java.rmi 7.8. Các lớp và các interface 2 2 3 3 3 trong gói java.rmi.registry\n\n[PAGE 7]\nChuẩn đầu ra Nội dung học phần KT01 KT02 KN01 NL01 NL02 NL03 2 2 3 3 3 3 7.9. Các lớp và các interface 2 2 3 3 3 trong gói java.rmi.server 6. TÀI LIỆU THAM KHẢO 6.1. Tài liệu học tập: [1]. Nguyễn Phương Lan - Hoàng Đức Hải, Java Lập trình mạng, Nhà xuất bản Giáo dục, 2005. 6.2. Tài liệu tham khảo: [2] Elliotte Rusty Harold, Java Network Programming, 4th Edition, O'Reilly Media, 2013.\n\n[PAGE 8]\n7. KẾ HOẠCH GIẢNG DẠY (LESSON PLAN) Các nội dung giảng dạy theo buổi học, thể hiện sự tương quan với các CĐR của học phần, các hoạt động dạy và học (ở lớp, ở nhà), và các bài đánh giá của học phần) Lịch trình giảng dạy: Đối với các học phần có lý thuyết và thực hành học liền (xen) nhau Tuần/ Hoạt động Bài Yêu cầu Số Loại Nội dung CĐR học Buổi dạy và học (hình thức đánh sinh viên tiết tiết học phần học giảng dạy) giá chuẩn bị [1] [2] [3] [4] [5] [6] [7] [8] Làm quen lớp, phổ biến nội dung CĐRKNHP02 Giảng viên: môn học, quy định học phần. CĐRNLHP02 - Giới thiệu bản thân và làm quen với các thành viên trong lớp. - Phổ biến nội dung học phần, phương pháp học 1 1 tập. - Giới thiệu tài liệu học tập và cách đọc tài liệu hiệu quả. - Nêu quy định học phần (về điểm chuyên cần, bài\n\n[PAGE 9]\nTuần/ Hoạt động Bài Yêu cầu Số Loại Nội dung CĐR học Buổi dạy và học (hình thức đánh sinh viên tiết tiết học phần học giảng dạy) giá chuẩn bị [1] [2] [3] [4] [5] [6] [7] [8] kiểm tra điều kiện và kiểm tra cuối học phần) Sinh viên: - Nghe giới thiệu, nêu câu hỏi và trình bày nguyện vọng. - Giới thiệu tình hình học tập của bản thân và của lớp. CĐRKTHP01, Giảng viên: … - Chuẩn bị CĐRNLHP03. Chương 1. Giới thiệu các mô hình trước nội - Thuyết trình có sử lập trình mạng dụng trình chiếu hình dung học Lý 1.1. Tổng quan về lập trình mạng ảnh/video minh họa. tập theo 1 3 thuyết 1.1.1. Khái niệm slide - Đặt câu hỏi, ra bài tập 1.1.2. Ngôn ngữ lập trình và giải đáp thắc mắc - Đọc 1.1.3. Thư viện hỗ trợ 1.2. Giao thức Internet của sinh viên. chương 1 tài liệu [1] Sinh viên:\n\n[PAGE 10]\nTuần/ Hoạt động Bài Yêu cầu Số Loại Nội dung CĐR học Buổi dạy và học (hình thức đánh sinh viên tiết tiết học phần học giảng dạy) giá chuẩn bị [1] [2] [3] [4] [5] [6] [7] [8] - Nghe thuyết trình trang 6-20 - Xem cách làm bài mẫu - Thực hành làm các bài tương tự Đặt câu hỏi thắc mắc và thảo luận về nội dung học Xem lại bài học chương 1 8 Tự học Đọc chương 2 tài liệu [1] trang 21-54 Chương 2. Lập trình đa luồng CĐRKTHP01, - Chuẩn bị CĐRKNHP01. trong Java Giảng viên: trước nội 2.1. Giới thiệu về luồng (thread) - Thuyết trình có sử dung học Lý 2 3 2.2. Vòng đời của một luồng trong dụng trình chiếu hình tập theo thuyết Java ảnh/video minh họa slide 2.3. Tạo và quản lý luồng - Làm bài mẫu - Hoàn thiện bài 2.4. Ví dụ minh họa sử dụng đa luồng\n\n[PAGE 11]\nTuần/ Hoạt động Bài Yêu cầu Số Loại Nội dung CĐR học Buổi dạy và học (hình thức đánh sinh viên tiết tiết học phần học giảng dạy) giá chuẩn bị [1] [2] [3] [4] [5] [6] [7] [8] - Đặt câu hỏi, ra bài tập thực hành và giải đáp thắc mắc chương 1 của sinh viên. - Đọc Sinh viên: chương 2 - Nghe thuyết trình tài liệu [1] trang 21- - Xem bài mẫu 54 - Tự làm các bài tập - Đặt câu hỏi thắc mắc và thảo luận về nội dung học CĐRKTHP01, Giảng viên: CĐRKNHP01. - Hướng dẫn sinh viên - SV làm bài tập nhóm. thực hành Thực 1 - SV làm bài tập thực hành sử dụng - Sửa lỗi cho sinh viên hành Sinh viên: ngôn ngữ Java - Thực hành theo yêu cầu của bài tập\n\n[PAGE 12]\nTuần/ Hoạt động Bài Yêu cầu Số Loại Nội dung CĐR học Buổi dạy và học (hình thức đánh sinh viên tiết tiết học phần học giảng dạy) giá chuẩn bị [1] [2] [3] [4]",
    "source_id": "temp_a9db6b81-d710-4dc6-b731-f081a77c346e_23_Lập trình mạng.pdf",
    "title": "temp_a9db6b81-d710-4dc6-b731-f081a77c346e_23_Lập trình mạng",
    "section": "",
    "section_level": 0,
    "page": 7,
    "course": "Unknown",
    "semester": "Unknown",
    "language": "vietnamese",
    "doc_type": "pdf",
    "keywords": [
      "dung",
      "sinh",
      "java",
      "trong",
      "page",
      "theo",
      "interface",
      "nghe",
      "minh",
      "trang"
    ],
    "hash": "f71d1ccf1ade15567b50a2653f6bc883",
    "created_at": "2025-09-20T12:48:11.093492",
    "start_char": 6099,
    "end_char": 9781,
    "chunk_index": 2,
    "point_id": "9ed082a8-5ba6-4cad-97b1-95151b00e6c5",
    "vector_index": 10
  },
  {
    "chunk_id": "c2c153a6-22c5-4380-a2a3-e8e9e87882b4",
    "content": "tập - Đặt câu hỏi thắc mắc và thảo luận về nội dung học CĐRKTHP01, Giảng viên: CĐRKNHP01. - Hướng dẫn sinh viên - SV làm bài tập nhóm. thực hành Thực 1 - SV làm bài tập thực hành sử dụng - Sửa lỗi cho sinh viên hành Sinh viên: ngôn ngữ Java - Thực hành theo yêu cầu của bài tập\n\n[PAGE 12]\nTuần/ Hoạt động Bài Yêu cầu Số Loại Nội dung CĐR học Buổi dạy và học (hình thức đánh sinh viên tiết tiết học phần học giảng dạy) giá chuẩn bị [1] [2] [3] [4] [5] [6] [7] [8] Xem lại bài học chương 2 8 Tự học Làm bài tập giáo viên giao Đọc chương 3 tài liệu [1] trang 54-69 Chương 2. Lập trình đa luồng CĐRKTHP01, Giảng viên: Đọc CĐRKTHP03, trong Java - Thuyết trình có sử chương 3 CĐRKNHP01, 2.5. Đồng bộ luồng dụng trình chiếu hình tài liệu [1] CĐRKNHP02, 2.6. Tiến trình treo CĐRNLHP02, ảnh/video minh họa trang 54- 69 CĐRNLHP03. - Làm bài mẫu - Đặt câu hỏi, ra bài tập Lý 3 3 và giải đáp thắc mắc thuyết của sinh viên. Sinh viên: - Nghe thuyết trình - Xem bài mẫu - Tự làm các bài tập Đặt câu hỏi thắc mắc và\n\n[PAGE 13]\nTuần/ Hoạt động Bài Yêu cầu Số Loại Nội dung CĐR học Buổi dạy và học (hình thức đánh sinh viên tiết tiết học phần học giảng dạy) giá chuẩn bị [1] [2] [3] [4] [5] [6] [7] [8] thảo luận về nội dung học CĐRKTHP01, CĐRKTHP02, Giảng viên: CĐRKTHP03, - Hướng dẫn sinh viên CĐRKNHP01, thực hành - SV làm bài tập nhóm. Thực CĐRKNHP02, 1 - Sửa lỗi cho sinh viên hành - SV làm bài tập thực hành chương 2 CĐRNLHP01, Sinh viên: CĐRNLHP02, - Thực hành theo yêu cầu CĐRNLHP03. của bài tập Xem lại bài học chương 2 8 Tự học Làm bài tập giáo viên giao Đọc chương 3 tài liệu [1] trang 69-82 Chương 3. Quản lý địa chỉ kết nối CĐRKTHP01, Giảng viên: - Chuẩn bị CĐRKTHP03, Lý mạng với các lớp InetAddress, Url - Thuyết trình có sử trước nội 4 3 CĐRKNHP01, thuyết và UrlConnection dụng trình chiếu hình dung học CĐRKNHP02, 3.1. Lớp InetAddress CĐRNLHP02, ảnh/video minh họa tập theo\n\n[PAGE 14]\nTuần/ Hoạt động Bài Yêu cầu Số Loại Nội dung CĐR học Buổi dạy và học (hình thức đánh sinh viên tiết tiết học phần học giảng dạy) giá chuẩn bị [1] [2] [3] [4] [5] [6] [7] [8] 3.1.1. Tạo đối tượng InetAddress CĐRNLHP03. - Làm bài mẫu slide 3.1.2. Các phương thức Getter - Đặt câu hỏi, ra bài tập - Làm bài 3.1.3. Các phương thức kiểm tra địa và giải đáp thắc mắc tập và gửi chỉ IP của sinh viên. lại cho 3.2. Lớp Url Sinh viên: giáo viên vào 3.2.1. Tạo các đối tượng Url - Nghe thuyết trình tuần tới 3.2.2. Nhận thông tin từ một URL - Xem bài mẫu - Đọc - Tự làm các bài tập 3.2.3. Phân tách một URL thành các chương 3 phần thông tin Đặt câu hỏi thắc mắc và tài liệu [1] 3.3. Lớp UrlConnection thảo luận về nội dung trang 69- học 82 CĐRKTHP01, Giảng viên: CĐRKTHP02, - SV làm bài tập nhóm. CĐRKTHP03, - Hướng dẫn sinh viên Thực 1 CĐRKNHP01, thực hành hành - SV làm bài tập thực hành chương 3 CĐRKNHP02, - Sửa lỗi cho sinh viên CĐRNLHP01, Sinh viên: CĐRNLHP02,\n\n[PAGE 15]\nTuần/ Hoạt động Bài Yêu cầu Số Loại Nội dung CĐR học Buổi dạy và học (hình thức đánh sinh viên tiết tiết học phần học giảng dạy) giá chuẩn bị [1] [2] [3] [4] [5] [6] [7] [8] CĐRNLHP03. - Thực hành theo yêu cầu của bài tập Xem lại bài học chương 3 8 Tự học Làm bài tập giáo viên giao Đọc chương 4 tài liệu [1] trang 82-91 Chương 4. Lập trình với giao thức CĐRKTHP01, - Chuẩn bị CĐRKTHP03, TCP Giảng viên: trước nội CĐRKNHP01, 4.1. Mô hình client/server CĐRKNHP02, - Thuyết trình có sử dung học 4.2. Mô hình truyền tin socket CĐRNLHP02, dụng trình chiếu hình tập theo 4.3. Lớp Socket CĐRNLHP03. ảnh/video minh họa slide Lý 3 4.4. Lớp ServerSocket - Làm bài mẫu - Đọc thuyết chương 3 4.5. Các bước xây dựng ứng dụng - Đặt câu hỏi, ra bài tập 5 tài liệu [1] Server và giải đáp thắc mắc trang 82- của sinh viên. 4.6. Các bước xây dựng ứng dụng 91 Client Sinh viên: - Nghe thuyết trình\n\n[PAGE 16]\nTuần/ Hoạt động Bài Yêu cầu Số Loại Nội dung CĐR học Buổi dạy và học (hình thức đánh sinh viên tiết",
    "source_id": "temp_a9db6b81-d710-4dc6-b731-f081a77c346e_23_Lập trình mạng.pdf",
    "title": "temp_a9db6b81-d710-4dc6-b731-f081a77c346e_23_Lập trình mạng",
    "section": "",
    "section_level": 0,
    "page": 12,
    "course": "Unknown",
    "semester": "Unknown",
    "language": "vietnamese",
    "doc_type": "pdf",
    "keywords": [
      "sinh",
      "dung",
      "trang",
      "theo",
      "page",
      "giao",
      "video",
      "minh",
      "nghe",
      "inetaddress"
    ],
    "hash": "4d80c9d9dbb1d5c6785e0b495b7951bb",
    "created_at": "2025-09-20T12:48:11.094599",
    "start_char": 9334,
    "end_char": 13182,
    "chunk_index": 3,
    "point_id": "7d97d2e2-ba0c-4b18-9333-444202f5ec64",
    "vector_index": 11
  },
  {
    "chunk_id": "927318fb-a2e8-4630-bd14-8e7efc7c05e6",
    "content": "truyền tin socket CĐRNLHP02, dụng trình chiếu hình tập theo 4.3. Lớp Socket CĐRNLHP03. ảnh/video minh họa slide Lý 3 4.4. Lớp ServerSocket - Làm bài mẫu - Đọc thuyết chương 3 4.5. Các bước xây dựng ứng dụng - Đặt câu hỏi, ra bài tập 5 tài liệu [1] Server và giải đáp thắc mắc trang 82- của sinh viên. 4.6. Các bước xây dựng ứng dụng 91 Client Sinh viên: - Nghe thuyết trình\n\n[PAGE 16]\nTuần/ Hoạt động Bài Yêu cầu Số Loại Nội dung CĐR học Buổi dạy và học (hình thức đánh sinh viên tiết tiết học phần học giảng dạy) giá chuẩn bị [1] [2] [3] [4] [5] [6] [7] [8] - Xem bài mẫu - Tự làm các bài tập Đặt câu hỏi thắc mắc và thảo luận về nội dung học CĐRKTHP01, CĐRKTHP02, Giảng viên: CĐRKTHP03, - Hướng dẫn sinh viên CĐRKNHP01, thực hành - SV làm bài tập nhóm. Thực CĐRKNHP02, 1 - Sửa lỗi cho sinh viên hành - SV làm bài tập thực hành chương 4 CĐRNLHP01, Sinh viên: CĐRNLHP02, - Thực hành theo yêu cầu CĐRNLHP03. của bài tập Xem lại bài học chương 4 8 Tự học Làm bài tập giáo viên giao Đọc chương 4 tài liệu [1] trang 92-101\n\n[PAGE 17]\nTuần/ Hoạt động Bài Yêu cầu Số Loại Nội dung CĐR học Buổi dạy và học (hình thức đánh sinh viên tiết tiết học phần học giảng dạy) giá chuẩn bị [1] [2] [3] [4] [5] [6] [7] [8] Chương 4. Lập trình với giao thức CĐRKTHP01, Giảng viên: Bài - Chuẩn bị CĐRKTHP03, TCP - Thuyết trình có sử kiểm trước nội CĐRKNHP01, 4.8. Đa luồng trong lập trình Socket dụng trình chiếu hình tra số dung học CĐRKNHP02, 4.9. Một số ví dụ CĐRNLHP02, ảnh/video minh họa 1 tập theo CĐRNLHP03. - Làm bài mẫu slide - Đặt câu hỏi, ra bài tập - Đọc và giải đáp thắc mắc chương 4 6 3 của sinh viên. tài liệu [1] trang 92- Sinh viên: 101 - Nghe thuyết trình - Xem bài mẫu - Tự làm các bài tập Đặt câu hỏi thắc mắc và thảo luận về nội dung học\n\n[PAGE 18]\nTuần/ Hoạt động Bài Yêu cầu Số Loại Nội dung CĐR học Buổi dạy và học (hình thức đánh sinh viên tiết tiết học phần học giảng dạy) giá chuẩn bị [1] [2] [3] [4] [5] [6] [7] [8] CĐRKTHP01, CĐRKTHP02, Giảng viên: CĐRKTHP03, - Hướng dẫn sinh viên CĐRKNHP01, thực hành - SV làm bài tập nhóm. Thực CĐRKNHP02, 1 - Sửa lỗi cho sinh viên hành - SV làm bài tập thực hành chương 4 CĐRNLHP01, Sinh viên: CĐRNLHP02, - Thực hành theo yêu cầu CĐRNLHP03. của bài tập Xem lại bài học chương 4 8 Tự học Làm bài tập giáo viên giao Đọc chương 5 tài liệu [1] trang 102-113 Chương 5. Lập trình với giao thức CĐRKTHP01, Giảng viên: - Chuẩn bị UDP CĐRKTHP03, - Thuyết trình có sử trước nội CĐRKNHP01, 5.1. Tổng quan về giao thức UDP Lý dụng trình chiếu hình dung học CĐRKNHP02, 7 2 5.2. Lớp DatagramPacket thuyết CĐRNLHP02, ảnh/video minh họa tập theo 5.3. Lớp DatagramSocket CĐRNLHP03. - Làm bài mẫu slide 5.4. Nhận các gói tin\n\n[PAGE 19]\nTuần/ Hoạt động Bài Yêu cầu Số Loại Nội dung CĐR học Buổi dạy và học (hình thức đánh sinh viên tiết tiết học phần học giảng dạy) giá chuẩn bị [1] [2] [3] [4] [5] [6] [7] [8] 5.5. Gửi các gói tin - Đặt câu hỏi, ra bài tập - Làm bài và giải đáp thắc mắc tập và gửi của sinh viên. lại cho Sinh viên: giáo viên vào - Nghe thuyết trình tuần tới - Xem bài mẫu - Đọc - Tự làm các bài tập chương 5 Đặt câu hỏi thắc mắc và tài liệu [1] thảo luận về nội dung trang 102- học 113 CĐRKTHP01, Giảng viên: CĐRKTHP02, - Hướng dẫn sinh viên CĐRKTHP03, thực hành Thực - SV làm bài tập nhóm. CĐRKNHP01, 2 - Sửa lỗi cho sinh viên CĐRKNHP02, hành - SV làm bài tập thực hành chương 5 Sinh viên: CĐRNLHP01, CĐRNLHP02, - Thực hành theo yêu cầu CĐRNLHP03. của bài tập\n\n[PAGE 20]\nTuần/ Hoạt động Bài Yêu cầu Số Loại Nội dung CĐR học Buổi dạy và học (hình thức đánh sinh viên tiết tiết học phần học giảng dạy) giá chuẩn bị [1] [2] [3] [4] [5] [6] [7] [8] Xem lại bài học chương 5 8 Tự học Làm bài tập giáo viên giao Đọc chương 5 tài liệu [1] trang 114-122 Chương 5. Lập trình với giao thức CĐRKTHP01, Giảng viên: - Chuẩn bị CĐRKTHP03, UDP - Thuyết trình có sử trước nội CĐRKNHP01,",
    "source_id": "temp_a9db6b81-d710-4dc6-b731-f081a77c346e_23_Lập trình mạng.pdf",
    "title": "temp_a9db6b81-d710-4dc6-b731-f081a77c346e_23_Lập trình mạng",
    "section": "",
    "section_level": 0,
    "page": 16,
    "course": "Unknown",
    "semester": "Unknown",
    "language": "vietnamese",
    "doc_type": "pdf",
    "keywords": [
      "sinh",
      "dung",
      "giao",
      "theo",
      "trang",
      "page",
      "socket",
      "video",
      "minh",
      "slide"
    ],
    "hash": "0f352b3035b39be6fee9c33b4845eefa",
    "created_at": "2025-09-20T12:48:11.095735",
    "start_char": 12697,
    "end_char": 16518,
    "chunk_index": 4,
    "point_id": "ca5b27d9-501f-46d2-9a07-4a47b15a7b96",
    "vector_index": 12
  },
  {
    "chunk_id": "8dd0c502-ee60-4aa6-a825-6a1aba2a53a8",
    "content": "viên: CĐRNLHP01, CĐRNLHP02, - Thực hành theo yêu cầu CĐRNLHP03. của bài tập\n\n[PAGE 20]\nTuần/ Hoạt động Bài Yêu cầu Số Loại Nội dung CĐR học Buổi dạy và học (hình thức đánh sinh viên tiết tiết học phần học giảng dạy) giá chuẩn bị [1] [2] [3] [4] [5] [6] [7] [8] Xem lại bài học chương 5 8 Tự học Làm bài tập giáo viên giao Đọc chương 5 tài liệu [1] trang 114-122 Chương 5. Lập trình với giao thức CĐRKTHP01, Giảng viên: - Chuẩn bị CĐRKTHP03, UDP - Thuyết trình có sử trước nội CĐRKNHP01, 5.6. Một số ví dụ dụng trình chiếu hình dung học CĐRKNHP02, CĐRNLHP02, ảnh/video minh họa tập theo CĐRNLHP03. - Làm bài mẫu slide - Đặt câu hỏi, ra bài tập - Làm bài Lý 8 2 và giải đáp thắc mắc của tập và gửi thuyết sinh viên. lại cho giáo viên Sinh viên: vào - Nghe thuyết trình tuần tới - Xem bài mẫu - Đọc - Tự làm các bài tập chương 6\n\n[PAGE 21]\nTuần/ Hoạt động Bài Yêu cầu Số Loại Nội dung CĐR học Buổi dạy và học (hình thức đánh sinh viên tiết tiết học phần học giảng dạy) giá chuẩn bị [1] [2] [3] [4] [5] [6] [7] [8] Đặt câu hỏi thắc mắc và tài liệu [1] thảo luận về nội dung trang 114- học 122 CĐRKTHP01, CĐRKTHP02, Giảng viên: CĐRKTHP03, - Hướng dẫn sinh viên - SV làm bài tập nhóm. CĐRKNHP01, thực hành Thực CĐRKNHP02, 2 - SV làm bài tập thực hành về đa - Sửa lỗi cho sinh viên hành CĐRNLHP01, Sinh viên: hình CĐRNLHP02, - Thực hành theo yêu cầu CĐRNLHP03. của bài tập Xem lại bài học chương 5 8 Tự học Làm bài tập giáo viên giao Đọc chương 6 tài liệu [1] trang 123-137 Chương 6. Tuần tự hóa đối tượng CĐRKTHP01, Giảng viên: - Chuẩn bị Lý CĐRKTHP03, 9 2 và ứng dụng trong lập trình mạng trước nội thuyết CĐRKNHP01, 6.1. Tuần tự hóa đối tượng dung học CĐRKNHP02,\n\n[PAGE 22]\nTuần/ Hoạt động Bài Yêu cầu Số Loại Nội dung CĐR học Buổi dạy và học (hình thức đánh sinh viên tiết tiết học phần học giảng dạy) giá chuẩn bị [1] [2] [3] [4] [5] [6] [7] [8] 6.2. Truyền các đối tượng thông qua CĐRNLHP02, - Thuyết trình có sử tập theo Socket CĐRNLHP03. dụng trình chiếu hình slide 6.3. Truyền các đối tượng thông qua ảnh/video minh họa - Làm bài giao thức UDP - Làm bài mẫu tập và gửi - Đặt câu hỏi, ra bài tập lại cho và giải đáp thắc mắc của giáo viên sinh viên. vào Sinh viên: tuần tới - Nghe thuyết trình - Đọc chương 7 - Xem bài mẫu tài liệu [1] - Tự làm các bài tập trang 123- Đặt câu hỏi thắc mắc và 137 thảo luận về nội dung học\n\n[PAGE 23]\nTuần/ Hoạt động Bài Yêu cầu Số Loại Nội dung CĐR học Buổi dạy và học (hình thức đánh sinh viên tiết tiết học phần học giảng dạy) giá chuẩn bị [1] [2] [3] [4] [5] [6] [7] [8] CĐRKTHP01, CĐRKTHP02, Giảng viên: CĐRKTHP03, - Hướng dẫn sinh viên - SV làm bài tập nhóm. CĐRKNHP01, thực hành Thực - SV làm bài tập thực hành về xây CĐRKNHP02, 2 - Sửa lỗi cho sinh viên hành dựng lớp và các thành phần trong CĐRNLHP01, Sinh viên: CĐRNLHP02, lớp - Thực hành theo yêu cầu CĐRNLHP03. của bài tập Xem lại bài học chương 7 8 Tự học Làm bài tập giáo viên giao Đọc chương 8 tài liệu [1] trang 138-150 CĐRKTHP01, Giảng viên: Bài - Chuẩn bị Chương 7. Kỹ thuật lập trình phân CĐRKTHP03, - Thuyết trình có sử kiểm trước nội tán RMI CĐRKNHP01, tra số Lý dụng trình chiếu hình dung học CĐRKNHP02, 10 2 7.1. Tổng quan 2 thuyết CĐRNLHP02, ảnh/video minh họa tập theo 7.2. Mục đích của RMI CĐRNLHP03. - Làm bài mẫu slide 7.3. Một số thuật ngữ\n\n[PAGE 24]\nTuần/ Hoạt động Bài Yêu cầu Số Loại Nội dung CĐR học Buổi dạy và học (hình thức đánh sinh viên tiết tiết học phần học giảng dạy) giá chuẩn bị [1] [2] [3] [4] [5] [6] [7] [8] 7.4. Các lớp trung gian Stub và - Đặt câu hỏi, ra bài tập - Làm bài Skeleton và giải đáp thắc mắc của tập và gửi 7.5. Cơ chế hoạt động của RMI sinh viên. lại cho 7.6. Cài đặt chương trình Sinh viên: giáo viên vào - Nghe thuyết trình tuần tới - Xem bài mẫu - Đọc - Tự làm các bài tập chương 8 Đặt câu hỏi thắc mắc và tài liệu",
    "source_id": "temp_a9db6b81-d710-4dc6-b731-f081a77c346e_23_Lập trình mạng.pdf",
    "title": "temp_a9db6b81-d710-4dc6-b731-f081a77c346e_23_Lập trình mạng",
    "section": "",
    "section_level": 0,
    "page": 20,
    "course": "Unknown",
    "semester": "Unknown",
    "language": "vietnamese",
    "doc_type": "pdf",
    "keywords": [
      "sinh",
      "dung",
      "theo",
      "page",
      "giao",
      "trang",
      "video",
      "minh",
      "slide",
      "nghe"
    ],
    "hash": "2453fda8d25a84dcd2470d3cb4f4baa8",
    "created_at": "2025-09-20T12:48:11.096855",
    "start_char": 16031,
    "end_char": 19797,
    "chunk_index": 5,
    "point_id": "eaef254d-592c-4c2c-b6a7-1251c6cb82c0",
    "vector_index": 13
  },
  {
    "chunk_id": "62e759ce-1950-45aa-a589-902a5a862e74",
    "content": "học (hình thức đánh sinh viên tiết tiết học phần học giảng dạy) giá chuẩn bị [1] [2] [3] [4] [5] [6] [7] [8] 7.4. Các lớp trung gian Stub và - Đặt câu hỏi, ra bài tập - Làm bài Skeleton và giải đáp thắc mắc của tập và gửi 7.5. Cơ chế hoạt động của RMI sinh viên. lại cho 7.6. Cài đặt chương trình Sinh viên: giáo viên vào - Nghe thuyết trình tuần tới - Xem bài mẫu - Đọc - Tự làm các bài tập chương 8 Đặt câu hỏi thắc mắc và tài liệu [1] thảo luận về nội dung trang 138- học 150 CĐRKTHP01, Giảng viên: CĐRKTHP02, - Hướng dẫn sinh viên CĐRKTHP03, thực hành Thực - SV làm bài tập nhóm. CĐRKNHP01, 2 - Sửa lỗi cho sinh viên CĐRKNHP02, hành - SV làm bài tập thực hành chương 7 Sinh viên: CĐRNLHP01, CĐRNLHP02, - Thực hành theo yêu cầu CĐRNLHP03. của bài tập\n\n[PAGE 25]\nTuần/ Hoạt động Bài Yêu cầu Số Loại Nội dung CĐR học Buổi dạy và học (hình thức đánh sinh viên tiết tiết học phần học giảng dạy) giá chuẩn bị [1] [2] [3] [4] [5] [6] [7] [8] Xem lại bài học chương 7 8 Tự học Làm bài tập giáo viên giao Đọc chương 9 tài liệu [1] trang 151-162 Chương 7. Kỹ thuật lập trình phân CĐRKTHP01, Giảng viên: - Chuẩn bị CĐRKTHP03, tán RMI - Thuyết trình có sử trước nội CĐRKNHP01, 7.7. Các lớp và các interface trong gói dụng trình chiếu hình dung học CĐRKNHP02, java.rmi CĐRNLHP02, ảnh/video minh họa tập theo 7.8. Các lớp và các interface trong gói CĐRNLHP03. - Làm bài mẫu slide java.rmi.registry - Đặt câu hỏi, ra bài tập - Làm bài Lý 11 2 7.9. Các lớp và các interface trong gói và giải đáp thắc mắc của tập và gửi thuyết java.rmi.server sinh viên. lại cho giáo viên Sinh viên: vào - Nghe thuyết trình tuần tới - Xem bài mẫu - Đọc - Tự làm các bài tập chương 9\n\n[PAGE 26]\nTuần/ Hoạt động Bài Yêu cầu Số Loại Nội dung CĐR học Buổi dạy và học (hình thức đánh sinh viên tiết tiết học phần học giảng dạy) giá chuẩn bị [1] [2] [3] [4] [5] [6] [7] [8] Đặt câu hỏi thắc mắc và tài liệu [1] thảo luận về nội dung trang 151- học 162 CĐRKTHP01, CĐRKTHP02, Giảng viên: CĐRKTHP03, - Hướng dẫn sinh viên CĐRKNHP01, thực hành - SV làm bài tập nhóm. Thực CĐRKNHP02, 2 - Sửa lỗi cho sinh viên hành - SV làm bài tập thực hành chương 7 CĐRNLHP01, Sinh viên: CĐRNLHP02, - Thực hành theo yêu cầu CĐRNLHP03. của bài tập Xem lại bài học chương 7 8 Tự học Làm bài tập giáo viên giao\n\n[PAGE 27]\n8. ĐÁNH GIÁ HỌC PHẦN (COURSE ASSESSMENT) Các thành phần, các bài đánh giá, nội dung đánh giá thể hiện sự tương quan với các chuẩn đầu ra của học phần, số lần đánh giá, tiêu chí đánh giá, tỷ lệ % trọng số điểm. Bảng 6: Đánh giá học phần Hình thức đánh Trọng số Nội dung đánh giá Thời điểm CĐR học phần Tiêu chí đánh giá giá (%) Đánh giá mức độ chuyên cần, thái độ học CĐRNLHP01, Chi tiết đánh giá theo Bảng 7: Chi Chuyên cần, thái độ Từ tuần 1 tập của người học trong CĐRNLHP02, tiết đánh giá chuyên cần và thái 10 % học tập đến tuần 11 toàn học phần CĐRNLHP03 độ học tập CĐRKTHP01, CĐRKTHP02, CĐRKTHP03, Người học làm bài Bài kiểm tra số 1 CĐRKNHP01, kiểm tra số 1 trong thời Chi tiết đánh giá theo Bảng 8: Chi dưới dạng thực Tuần 6 CĐRKNHP02, 15 % gian 1 tiết nhằm kiểm tiết đánh giá bài kiểm tra giữa kỳ hành CĐRNLHP01, tra kiến thức CĐRNLHP02, CĐRNLHP03. Bài kiểm tra số 2 Người học làm bài CĐRKTHP01, Chi tiết đánh giá theo Bảng 8: Chi Tuần 10 15 % dưới dạng thực kiểm tra số 2 trong thời CĐRKTHP02, tiết đánh giá bài kiểm tra giữa kỳ\n\n[PAGE 28]\nHình thức đánh Trọng số Nội dung đánh giá Thời điểm CĐR học phần Tiêu chí đánh giá giá (%) hành gian 1 tiết nhằm kiểm CĐRKTHP03, tra kiến thức CĐRKNHP01, CĐRKNHP02, CĐRNLHP01, CĐRNLHP02, CĐRNLHP03. Sinh viên làm bài thi Theo lịch Bài thi cuối khóa cuối khoá theo hình nhà trường Chi tiết đánh giá theo Bảng 9: Tiêu 60% dưới dạng bài tập thức báo cáo bài tập sau khi khóa chí đánh giá bài tập lớn lớn lớn. (90 phút) học kết thúc. Bảng 7: Chi tiết đánh giá chuyên cần và thái độ học tập CHI TIẾT ĐÁNH GIÁ (ĐIỂM)",
    "source_id": "temp_a9db6b81-d710-4dc6-b731-f081a77c346e_23_Lập trình mạng.pdf",
    "title": "temp_a9db6b81-d710-4dc6-b731-f081a77c346e_23_Lập trình mạng",
    "section": "",
    "section_level": 0,
    "page": 25,
    "course": "Unknown",
    "semester": "Unknown",
    "language": "vietnamese",
    "doc_type": "pdf",
    "keywords": [
      "sinh",
      "theo",
      "dung",
      "trong",
      "page",
      "gian",
      "trang",
      "interface",
      "java",
      "nghe"
    ],
    "hash": "4d75db4948428717ef3a5bce55bb0679",
    "created_at": "2025-09-20T12:48:11.097888",
    "start_char": 19363,
    "end_char": 23218,
    "chunk_index": 6,
    "point_id": "d0974b2c-84b5-4448-8330-40aeccebf5ce",
    "vector_index": 14
  },
  {
    "chunk_id": "af231c02-b104-45e8-9f47-78169ef69e77",
    "content": "số Nội dung đánh giá Thời điểm CĐR học phần Tiêu chí đánh giá giá (%) hành gian 1 tiết nhằm kiểm CĐRKTHP03, tra kiến thức CĐRKNHP01, CĐRKNHP02, CĐRNLHP01, CĐRNLHP02, CĐRNLHP03. Sinh viên làm bài thi Theo lịch Bài thi cuối khóa cuối khoá theo hình nhà trường Chi tiết đánh giá theo Bảng 9: Tiêu 60% dưới dạng bài tập thức báo cáo bài tập sau khi khóa chí đánh giá bài tập lớn lớn lớn. (90 phút) học kết thúc. Bảng 7: Chi tiết đánh giá chuyên cần và thái độ học tập CHI TIẾT ĐÁNH GIÁ (ĐIỂM) Tiêu chí 0 - <5 5 - <7 7 - <9 9 - 10 Từ 10% đến 20% số Vắng mặt trên lớp Trên 20% số tiết học Đủ 20% số tiết học Không vắng tiết học nào tiết học Trong lớp không tập trung vào bài Có tham giao thảo luận Tích cực tham gia Tích cực tham gia Thảo luận có hiệu quả. giảng; Rất ít tham gia thảo luận nhưng không chủ động. thảo luận. Hoàn bài giảng, hoàn Hoàn thành tốt các bài Không tương tác với giảng viên; Hoàn thành các bài tập thành tốt các bài tập thành các bài tập tập được giao trên lớp Không hoàn thành các bài tập được được giao trên lớp và ở được giao trên lớp và trên lớp và ở nhà và ở nhà giao trên lớp và ở nhà nhà ở nhà\n\n[PAGE 29]\nBảng 8: Chi tiết đánh giá bài kiểm tra giữa kỳ Tiêu chí CHI TIẾT ĐÁNH GIÁ (ĐIỂM) Trọng số 0 - <3 3 - <5 5 - <7 7 - <9 9 - 10 Đáp ứng yêu Làm đúng từ mức 50- Làm đúng từ mức Làm đúng trên mức 90% yêu cầu. cầu nội dung 70% yêu cầu. 70-90% yêu cầu. về kiến thức, Làm đúng dưới Làm đúng dưới Giải thích rõ ràng, logic tất cả kỹ năng và mức 20% yêu cầu. mức 50% yêu cầu. Giải thích rõ ràng các Giải thích rõ ràng các bài. phần đã làm đúng. các phần đã làm thái độ Có tính sáng tạo, tìm tòi đưa ra nhiều đúng. (90%) phương pháp giải. Mức độ logic, hợp Hình thức Chưa logic, hợp lý. Logic, hợp lý. Logic, hợp lý. Logic, hợp lý. lý bình thường. trình bày Khó đọc. Khá dễ đọc. Dễ đọc. Dễ đọc. Không dễ đọc. code (10%) Không đẹp mắt. Bình thường. Khá đẹp mắt. Đẹp mắt. Không đẹp mắt. Bảng 9: Tiêu chí đánh giá bài tập lớn Tiêu chí CHI TIẾT ĐÁNH GIÁ (ĐIỂM) Trọng số 0 - <3 3 - <5 5 - <7 7 - <9 9 - 10 Thực hiện được rất ít Thực hiện được ít Thực hiện hầu hết Thực hiện đầy đủ và yêu cầu của Bài tập lớn yêu cầu của Bài tập lớn Thực hiện đầy đủ Đáp ứng yêu cầu của Bài tập lớn xuất sắc yêu cầu của Khảo sát và đặc tả Khảo sát và đặc tả yêu cầu của Bài tập lớn yêu cầu nội Khảo sát và đặc tả Bài tập lớn yêu cầu nghiệp vụ rất yêu cầu nghiệp vụ sơ sài, Khảo sát và đặc tả dung về yêu cầu nghiệp vụ đầy đủ Khảo sát và đặc tả sơ sài, còn thiếu rất còn thiếu và nhiều sai sót. yêu cầu nghiệp vụ tốt kiến thức, Phân tích, thiết kế yêu cầu nghiệp vụ tốt nhiều và nhiều sai sót. Phân tích, thiết kế Phân tích, thiết kế tốt kỹ năng và còn có một số sai sót. Phân tích, thiết kế tốt Phân tích, thiết kế không tốt, có nhiều lỗi. Xây dựng và cài đặt thái độ Xây dựng và cài đặt Xây dựng, cài đặt không tốt, có rất nhiều lỗi. Xây dựng và cài đặt được ứng dụng chạy (90%) được ứng dụng nhưng được ứng dụng và kiểm Chưa xây dựng và được ứng dụng nhưng tốt. còn có một số lỗi. thử lỗi tốt. cài đặt được ứng dụng. chưa chạy được.\n\n[PAGE 30]\nTiêu chí CHI TIẾT ĐÁNH GIÁ (ĐIỂM) Trọng số 0 - <3 3 - <5 5 - <7 7 - <9 9 - 10 Trình bày Bài tập Trình bày Bài tập Cấu trúc Báo cáo Bố cục rõ ràng, cấu Bố cục rõ ràng, cấu lớn (phần nhiệm vụ lớn (phần nhiệm vụ chưa thật phù hợp trúc phù hợp, văn trúc phù hợp, văn được giao) còn lúng được giao) còn lúng Trình bày Bài tập phong khoa học phong khoa túng, không hiểu các túng, chưa hiểu hết các lớn (phần nhiệm vụ Trình bày Bài tập Trình bày Bài tập nhiệm vụ được",
    "source_id": "temp_a9db6b81-d710-4dc6-b731-f081a77c346e_23_Lập trình mạng.pdf",
    "title": "temp_a9db6b81-d710-4dc6-b731-f081a77c346e_23_Lập trình mạng",
    "section": "",
    "section_level": 0,
    "page": 29,
    "course": "Unknown",
    "semester": "Unknown",
    "language": "vietnamese",
    "doc_type": "pdf",
    "keywords": [
      "giao",
      "logic",
      "tham",
      "dung",
      "theo",
      "page",
      "phong",
      "khoa",
      "gian",
      "sinh"
    ],
    "hash": "cf8781cc8d4aa1cc4c3de09723ce8cae",
    "created_at": "2025-09-20T12:48:11.098897",
    "start_char": 22719,
    "end_char": 26238,
    "chunk_index": 7,
    "point_id": "7795da83-71df-4ce5-ade1-1a3912b32a80",
    "vector_index": 15
  },
  {
    "chunk_id": "41cd94a1-4f2c-455e-ba9d-16588f11e8e3",
    "content": "Trọng số 0 - <3 3 - <5 5 - <7 7 - <9 9 - 10 Trình bày Bài tập Trình bày Bài tập Cấu trúc Báo cáo Bố cục rõ ràng, cấu Bố cục rõ ràng, cấu lớn (phần nhiệm vụ lớn (phần nhiệm vụ chưa thật phù hợp trúc phù hợp, văn trúc phù hợp, văn được giao) còn lúng được giao) còn lúng Trình bày Bài tập phong khoa học phong khoa túng, không hiểu các túng, chưa hiểu hết các lớn (phần nhiệm vụ Trình bày Bài tập Trình bày Bài tập nhiệm vụ được giao. nhiệm vụ được giao. được giao) còn lúng túng. lớn (phần nhiệm vụ lớn (phần nhiệm vụ Trả lời đúng dưới Trả lời đúng 30-40% Trả lời đúng 50-60% được giao) rõ ràng, diễn được giao) rõ ràng, diễn 20% câu hỏi của GV.. câu hỏi của GV. câu hỏi của GV. đạt logic. đạt logic. Trả lời đúng 70-80% Trả lời được tất cả câu hỏi của GV. các câu hỏi của GV Mức độ logic, hợp lý Hình Chưa logic, hợp lý. Logic, hợp lý. Logic, hợp lý. Logic, hợp lý. bình thường. thức trình Khó đọc. Khá dễ đọc. Dễ đọc. Dễ đọc. Không dễ đọc. bày (10%) Không đẹp mắt. Bình thường. Khá đẹp mắt. Đẹp mắt. Không đẹp mắt.\n\n[PAGE 31]\n9. QUY ĐỊNH CỦA HỌC PHẦN (COURSE REQUIREMENTS AND EXPECTATION) 9.1 Quy định về tham dự lớp học - Sinh viên có trách nhiệm tham dự đầy đủ các buổi học. Trong trường hợp nghỉ học do lý do bất khả kháng thì phải có giấy tờ chứng minh đầy đủ và hợp lý. - Sinh viên vắng quá 20% số tiết học dù có lý do hay không có lý do đều bị coi như không hoàn thành môn học và phải đăng ký học lại. 9.2 Quy định về hành vi lớp học - Học phần được thực hiện trên nguyên tắc tôn trọng người học và người dạy. Mọi hành vi làm ảnh hưởng đến quá trình dạy và học đều bị nghiêm cấm. - Sinh viên phải đi học đúng giờ quy định. Sinh viên đi trễ quá 10 phút sau khi giờ học bắt đầu sẽ không được tham dự buổi học. - Tuyệt đối không làm ồn, gây ảnh hưởng đến người khác trong quá trình học. - Tuyệt đối không được ăn uống, nhai kẹo cao su, sử dụng các thiết bị như điện thoại, máy nghe nhạc trong giờ học. - Máy tính xách tay, máy tính bảng chỉ được thực hiện vào mục đích ghi chép bài giảng, tính toán phục vụ bài giảng, bài tập, tuyệt đối không dùng vào việc khác. 10. NGÀY PHÊ DUYỆT: ………………….. TRƯỞNG KHOA GIẢNG VIÊN/ BỘ MÔN (ký và ghi rõ họ tên) (ký và ghi rõ họ tên) Trần Đăng Công Phạm Văn Tiệp",
    "source_id": "temp_a9db6b81-d710-4dc6-b731-f081a77c346e_23_Lập trình mạng.pdf",
    "title": "temp_a9db6b81-d710-4dc6-b731-f081a77c346e_23_Lập trình mạng",
    "section": "",
    "section_level": 0,
    "page": 31,
    "course": "Unknown",
    "semester": "Unknown",
    "language": "vietnamese",
    "doc_type": "pdf",
    "keywords": [
      "giao",
      "logic",
      "sinh",
      "khoa",
      "tham",
      "trong",
      "phong",
      "page",
      "course",
      "requirements"
    ],
    "hash": "b0c126bccd510c3e2d569bed6100ec83",
    "created_at": "2025-09-20T12:48:11.099558",
    "start_char": 25812,
    "end_char": 28012,
    "chunk_index": 8,
    "point_id": "ef0751a7-68c8-406c-b511-c76692008ad7",
    "vector_index": 16
  },
  {
    "chunk_id": "214edacd-4260-4c4d-a376-716b9ef4c21a",
    "content": "[PAGE 1]\nCHƯƠNG 2: Lập trình đa luồng trong Java Giảng viên: Ths. Phạm Văn Tiệp Slide: số….\n\n[PAGE 2]\nNội dung bài học Khái niệm về đa nhiệm và đa luồng ▪ Tạo và quản lý luồng ▪ Đồng bộ luồng ▪ Đa luồng trên Java Swing ▪ Tiến trình treo ▪ SlideS:li dseố: …số .2\n\n[PAGE 3]\nKHÁI NIỆM VỀ ĐA NHIỆM VÀ ĐA LUỒNG Slide: số….\n\n[PAGE 4]\nĐa nhiệm Đa nhiệm là kỹ thuật cho phép nhiều công việc được thực hiện cùng ▪ một lúc trên máy tính. Nếu có nhiều CPU, các công việc có thể được thực hiện song song ▪ trên từng CPU. Trong trường hợp nhiều công việc cùng chia sẻ một CPU, từng phần ▪ của mỗi công việc sẽ được CPU thực hiện xen kẽ. Nhiều công việc thi hành trên một CPU SlideS:li dseố: …số .4\n\n[PAGE 5]\nĐa nhiệm Hai kỹ thuật đa nhiệm cơ bản: Đa tiến trình: Nhiều chương trình chạy đồng thời. Mỗi chương trình ▪ có một vùng dữ liệu độc lập. Đa luồng: Một chương trình có nhiều luồng cùng chạy đồng thời. Các ▪ luồng dùng chung vùng dữ liệu của chương trình. SlideS:li dseố: …số .5\n\n[PAGE 6]\nLuồng và đa luồng Luồng là đơn vị nhỏ nhất của đoạn mã có thể thực thi được để thực hiện ▪ một công việc riêng biệt Một chương trình có nhiều luồng thực hiện cùng lúc gọi là đa luồng. ▪ program program SlideS:li dseố: …số .6\n\n[PAGE 7]\nĐặc điểm đa luồng ▪ Đa luồng giữ thời gian nhàn rỗi của hệ thống thành nhỏ nhất. (tận dụng tối đa CPU) ▪ Trong đa nhiệm, nhiều chương trình chạy đồng thời, mỗi chương trình có ít nhất một luồng trong nó. SlideS:li dseố: …số .7\n\n[PAGE 8]\nTẠO VÀ QUẢN LÝ LUỒNG Slide: số….\n\n[PAGE 9]\nTạo và quản lý luồng Khi chương trình Java thực thi hàm main() tức là luồng main được thực thi. ▪ Luồng này được tạo ra một cách tự động, tại đây: Các luồng con sẽ được tạo ra từ đó o Nó là luồng cuối cùng kết thúc việc thực hiện. o Khi luồng chính ngừng thực thi, chương trình bị chấm dứt o Luồng có thể được tạo ra bằng 2 cách: ▪ Kế thừa từ lớp Thread o Thực thi từ giao diện Runnable. o SlideS:li dseố: …số .9\n\n[PAGE 10]\nLớp Thread public class Thread extends Runable(){ public static final int MAX_PRIORITY = 10; public static final int MIN_PRIORITY = 1; public static final int NORM_PRIORITY = 5; //Nested class static class State(){};//Trạng thái của luồng //Xử lý sự kiện luồng bị dừng do không bắt ngoại lệ static interface UncaughtExceptionHandler(){} //Constructor public Thread(){}; public Thread(Runable target); public Thread(Runable target, String threadName); //public methods... } SlidSelid: es: ốs…ố 1.0\n\n[PAGE 11]\nMột số phương thức chính void start(): bắt đầu thực thi luồng ▪ void run(): thực thi luồng. Mặc định được gọi trong phương thức start() ▪ void setName(String name): đặt tên cho luồng ▪ void setPriority(int priority): thiết lập độ ưu tiên ▪ void interrupt(): ngắt luồng đang thực thi ▪ final void join(): chờ luồng kết thúc ▪ final void join(long milisecond): chờ luồng kết thúc ▪ final void join(long milisecond, int nanosecond): chờ luồng kết thúc ▪ final boolean isAlive(): trả lại true nếu luồng còn đang thực thi ▪ Thread.State getState(): Trả lại trạng thái của luồng ▪ SlidSelid: es:ố s…ố 1.1\n\n[PAGE 12]\nMột số phương thức static void yield(): nhường các luồng có cùng mức ưu tiên thực thi trước ▪ void sleep(long millisec): tạm dừng luồng trong khoảng thời gian tối thiểu ▪ nào đó, nhưng vẫn giữ quyền điều khiển Ủy nhiệm xử lý ngoại lệ InterruptException cho phương thức gọi o void sleep(long millisec, int nanosecond) ▪ Thread currentThread() ▪ SlidSelid: es: ốs…ố 1.2\n\n[PAGE 13]\nTrạng thái của luồng NEW: luồng được tạo, chưa thực thi ▪ RUNNABLE: có thể thực thi ▪ BLOCKED: luồng bị tạm khóa ▪ WAITING: chờ các luồng khác thực thi ▪ TIMED_WAITING: chờ với thời gian xác định ▪ TERMINATED: kết thúc luồng ▪ SlidSelid: es: ốs…ố 1.3\n\n[PAGE 14]\nVòng đời của một luồng SlidSelid: es: ốs…ố 1.4\n\n[PAGE 15]\nTạo thread(1) –Kế thừa lớp Thread class MyThread extends Thread{ //Ghi đè phương thức run() của lớp cha public void run(){ //do something } //Định nghĩa các phương thức khác } SlidSelid: es: ốs…ố 1.5\n\n[PAGE 16]\nTạo thread(1) –Kế thừa lớp Thread class OtherMyThread extends Thread{ private Thread t; //Ghi đè phương thức run() của lớp cha public void run(){ //do something } //Ghi đè phương thức start() của lớp cha public void start(){ if (t == null){ t = new",
    "source_id": "temp_cdb2bfe8-b7b1-4964-9ebb-7e389d642ead_2. Lập trình đa luồng (1).pdf",
    "title": "temp_cdb2bfe8-b7b1-4964-9ebb-7e389d642ead_2. Lập trình đa luồng (1)",
    "section": "",
    "section_level": 0,
    "page": 1,
    "course": "Unknown",
    "semester": "Unknown",
    "language": "vietnamese",
    "doc_type": "pdf",
    "keywords": [
      "page",
      "thread",
      "void",
      "public",
      "final",
      "trong",
      "slides",
      "static",
      "slidselid",
      "class"
    ],
    "hash": "768ed1433f58ce76c70d4bb341782061",
    "created_at": "2025-09-20T12:48:12.540154",
    "start_char": 2,
    "end_char": 4199,
    "chunk_index": 0,
    "point_id": "7f8c2e58-f7d2-4c4c-8f59-87ef2d6a6c0d",
    "vector_index": 17
  },
  {
    "chunk_id": "e50af3f0-a779-4efc-a4be-c5cd4f3c7211",
    "content": "▪ SlidSelid: es: ốs…ố 1.3\n\n[PAGE 14]\nVòng đời của một luồng SlidSelid: es: ốs…ố 1.4\n\n[PAGE 15]\nTạo thread(1) –Kế thừa lớp Thread class MyThread extends Thread{ //Ghi đè phương thức run() của lớp cha public void run(){ //do something } //Định nghĩa các phương thức khác } SlidSelid: es: ốs…ố 1.5\n\n[PAGE 16]\nTạo thread(1) –Kế thừa lớp Thread class OtherMyThread extends Thread{ private Thread t; //Ghi đè phương thức run() của lớp cha public void run(){ //do something } //Ghi đè phương thức start() của lớp cha public void start(){ if (t == null){ t = new Thread (this); t.start (); } } //Định nghĩa các phương thức khác } SlidSelid: es: ốs…ố 1.6\n\n[PAGE 17]\nVí dụ class PingPongThread extends Thread { private String word; private int delay; PingPongThread(String s, int d){ this.word =s; this.delay=d; } public void run(){ try{ for(int i = 1; i <= 10; i++){ System.out.print(word + “ ” + i); sleep(delay); } }catch(InterruptedException e){ System.out.println(“Thread “ + word + “interrupted.”); } } public static void main(String[] args){ new PingPongThread(\"ping\",500).start(); new PingPongThread(\"PONG\",1000).start(); } SlidSelid: es: ốs…ố 1.7\n\n[PAGE 18]\nVí dụ - Cách viết khác class PingPongThread extends Thread { private String word; private int delay; private Thread t; PingPongThread(String s, int d){ this.word =s; this.delay=d; } public void run(){ try{ for(int i = 1; i <= 10; i++){ System.out.print(word + “ ” + i); sleep(delay); } } catch(InterruptedException e){ System.out.println(“Thread “ + word + “interrupted.”); } } SlidSelid: es: ốs…ố 1.8\n\n[PAGE 19]\nVí dụ - Cách viết khác public void start(){ if(t==null){ t = new Thread(this); t.start(); } } public static void main(String[] args){ new PingPongThread(\"ping\",500).start(); new PingPongThread(\"PONG\",1000).start(); } SlidSelid: es: ốs…ố 1.9\n\n[PAGE 20]\nGiao diện Runnable public interface Runnable{ public void run(); } Kế thừa từ Thread hay triển khai Runnable? ▪ Runnable đơn giản hơn, phù hợp khi chúng ta chỉ quan tâm đến luồng o thực thi những gì bằng cách ghi đè phương thức run() Lớp triển khai từ Runnable có thể kế thừa từ lớp khác o Thread cung cấp nhiều phương thức, cho phép điều khiển luồng, kiểm o tra các trạng thái của luồng Lớp kế thừa từ Thread không thể kế thừa thêm từ lớp khác o SlidSelid: es: ốs…ố 2.0\n\n[PAGE 21]\nTạo Thread(2) - Triển khai Runable class MyThread implements Runnable{ //Định nghĩa phương thức run() public void run() { //do something } //Định nghĩa các phương thức khác của lớp } SlidSelid: es: ốs…ố 2.1\n\n[PAGE 22]\nVí dụ class PingPongRunnable implements Runnable{ private String word; private int delay; PingPongRunnable(String s, int d){ this.word =s; this.delay=d; } public void run(){ try{ for(int i = 1; i <= 10; i++){ System.out.print(word + “ ” + i); sleep(delay); } } catch(InterruptedException e){ System.out.println(“Thread “ + word + “interrupted.”); } } SlidSelid: es: ốs…ố 2.2\n\n[PAGE 23]\nVí dụ public static void main(String[] args){ Runnable ping = new PingPongRunnable(\"ping\",500); Runnable pong = new PingPongThread(\"PONG\",1000); new Thread(ping).start(); new Thread(pong).start(); } SlidSelid: es: ốs…ố 2.3\n\n[PAGE 24]\nĐỒNG BỘ LUỒNG Slide: số….\n\n[PAGE 25]\nĐồng bộ luồng Khi có nhiều luồng cùng truy cập vào một tài nguyên, cần đồng bộ luồng để ▪ tránh các luồng “giẫm chân nhau”, thậm chí gây hỏng tài nguyên. Cơ chế đồng bộ luồng của Java: ▪ Mỗi đối tượng trong Java có một khóa o Khi có một luồng truy cập vào đối tượng, khóa này mặc định được điều o khiển bởi luồng đó Khi có nhiều luồng đồng thời cùng truy cập, chỉ luồng nào có khóa mới o được truy cập, các luồng khác phải chờ. SlidSelid: es: ốs…ố 2.5\n\n[PAGE 26]\nVí dụ -Truy cập đa luồng không đồng bộ public class NonSynchronizedCounter { private static int count = 0; public static void increment() { ++count; System.out.println(\"Count is \" + count + \" -\" + System.nanoTime()); } public static void decrement() { --count; System.out.println(\"Count is \" + count + \" -\" + System.nanoTime()); } } SlidSelid: es: ốs…ố 2.6\n\n[PAGE 27]\nVí dụ -Truy cập đa luồng không đồng bộ public class TestNonSynchronizedCounter { public static void main(String[] args) { Thread threadIncrement = new Thread() { @Override public void run() { for (int i = 0; i < 5; ++i) NonSynchronizedCounter.increment(); } }; Thread threadDecrement = new Thread() { @Override public void run() { for (int i = 0; i < 5; ++i) NonSynchronizedCounter.decrement(); } }; threadIncrement.start(); threadDecrement.start(); } } SlidSelid: es: ốs…ố 2.7\n\n[PAGE 28]\nKết quả thực thi Kết quả khác nhau ở những lần chạy khác nhau. Ví dụ ▪ SlidSelid: es: ốs…ố 2.8\n\n[PAGE 29]\nGiải thích Thực hiện lệnh ++count; gồm 3 bước: ▪ Bước 1: Lấy giá trị của count từ bộ nhớ o Bước 2: Cộng 1 vào giá trị o Bước 3: Cất kết",
    "source_id": "temp_cdb2bfe8-b7b1-4964-9ebb-7e389d642ead_2. Lập trình đa luồng (1).pdf",
    "title": "temp_cdb2bfe8-b7b1-4964-9ebb-7e389d642ead_2. Lập trình đa luồng (1)",
    "section": "",
    "section_level": 0,
    "page": 14,
    "course": "Unknown",
    "semester": "Unknown",
    "language": "vietnamese",
    "doc_type": "pdf",
    "keywords": [
      "thread",
      "public",
      "void",
      "page",
      "slidselid",
      "start",
      "word",
      "string",
      "system",
      "private"
    ],
    "hash": "a6f917b202b63d36dc9a24dfc368d55c",
    "created_at": "2025-09-20T12:48:12.540926",
    "start_char": 3645,
    "end_char": 8385,
    "chunk_index": 1,
    "point_id": "08fa34c5-18ce-40fe-a8d9-3b740cd96c3e",
    "vector_index": 18
  },
  {
    "chunk_id": "3fb38162-26cc-4605-869c-f908a9f39a78",
    "content": "(int i = 0; i < 5; ++i) NonSynchronizedCounter.increment(); } }; Thread threadDecrement = new Thread() { @Override public void run() { for (int i = 0; i < 5; ++i) NonSynchronizedCounter.decrement(); } }; threadIncrement.start(); threadDecrement.start(); } } SlidSelid: es: ốs…ố 2.7\n\n[PAGE 28]\nKết quả thực thi Kết quả khác nhau ở những lần chạy khác nhau. Ví dụ ▪ SlidSelid: es: ốs…ố 2.8\n\n[PAGE 29]\nGiải thích Thực hiện lệnh ++count; gồm 3 bước: ▪ Bước 1: Lấy giá trị của count từ bộ nhớ o Bước 2: Cộng 1 vào giá trị o Bước 3: Cất kết quả vào bộ nhớ o Thực hiện lệnh --count tương tự ▪ Hai luồng khác nhau cùng truy cập tới giá trị count ở những thời điểm khác nhau trên ▪ bộ nhớ. Ví dụ: count có giá trị là 0 o Luồng threadIncrement đang thực hiện bước 2 thì luồng threadDecrement truy cập o vào bộ nhớ lấy ra giá trị của count Luồng threadIncrement cất giá trị mới (1) vào bộ nhớ và chuẩn bị thực hiện o phương thức hiển thị System.out.println(), luồng threadDecrement cất giá trị sau khi biến đổi (-1) vào bộ nhớ Luồng threadIncrement hiển thị kết quả là -1 o SlidSelid: es: ốs…ố 2.9\n\n[PAGE 30]\nTừ khóa synchronized Khi một đối tượng, phương thức hoặc một đoạn mã được đánh dấu là ▪ synchronized, luồng nào truy cập tới phải chờ khóa → cho phép đồng bộ các luồng // synchronized a method public synchronized void methodA() { ... } public void methodB() { // synchronized a block of codes synchronized(this) { ... } // synchronized a block of codes based on another object synchronized(anObject) { ... } ... } SlidSelid: es: ốs…ố 3.0\n\n[PAGE 31]\nĐồng bộ luồng - Cách tiếp cận 1 public class SynchronizedCounter { private static int count = 0; public synchronized static void increment() { ++count; System.out.println(\"Count is \" + count + \" -\" + System.nanoTime()); } public synchronized static void decrement() { --count; System.out.println(\"Count is \" + count + \" -\" + System.nanoTime()); } } SlidSelid: es: ốs…ố 3.1\n\n[PAGE 32]\nĐồng bộ luồng - Cách tiếp cận 2 public class NonSynchronizedCounter { private static int count = 0; public void increment() { synchronized(this){ ++count; System.out.println(\"Count is \" + count + \" -\" + System.nanoTime()); } } public void decrement() { synchronized(this){ --count; System.out.println(\"Count is \" + count + \" -\" + System.nanoTime()); } } } SlidSelid: es: ốs…ố 3.2\n\n[PAGE 33]\nĐồng bộ luồng - Cách tiếp cận 3 public class NonSynchronizedCounter { private static int count = 0; public void increment() { ++count; System.out.println(\"Count is \" + count + \" -\" + System.nanoTime()); } public void decrement() { --count; System.out.println(\"Count is \" + count + \" -\" + System.nanoTime()); } } SlidSelid: es: ốs…ố 3.3\n\n[PAGE 34]\nĐồng bộ luồng - Cách tiếp cận 3 public class SynchronizedTestCounter { public static void main(String[] args) { NonSynchronizedCounter counter = new NonSynchronizedCounter(); Thread threadIncrement = new Thread() { @Override public void run() { synchronized(counter){ for (int i = 0; i < 5; ++i) counter.increment(); } } }; SlidSelid: es: ốs…ố 3.4\n\n[PAGE 35]\nĐồng bộ luồng - Cách tiếp cận 3 Thread threadDecrement = new Thread() { @Override public void run() { synchronized(counter){ for (int i = 0; i < 5; ++i) counter.decrement(); } }; threadIncrement.start(); threadDecrement.start(); } } SlidSelid: es: ốs…ố 3.5\n\n[PAGE 36]\nHạn chế của synchronized Không tận dụng triệt để tài nguyên (biến đa luồng thành đơn luồng) ▪ Các phương thức/đoạn mã synchronized có tốc độ thực hiện chậm ▪ → Kỹ thuật “chờ-báo” (wait-notify): sử dụng các phương thức của lớp Object wait(): giúp một luồng chờ một sự kiện xảy ra o notify(): thông báo cho ít nhất 1 luồng về sự kiện xảy ra o notifyAll(): thông báo cho tất cả các luồng về sự kiện o Chỉ được gọi trong các khối lệnh được chỉ định đồng bộ bằng synchronized o SlidSelid: es: ốs…ố 3.6\n\n[PAGE 37]\nCác phương thức public final void wait(long timeout) throws InterruptedException ▪ luồng hiện thời chờ cho tới khi được cảnh báo hoặc một khoảng thời gian o timeout nhất định. Nếu timeout bằng 0 thì phương thức sẽ chỉ chờ cho tới khi có cảnh báo về sự kiện. public final void notify() ▪ Cảnh báo ít nhất một luồng đang chờ một sự kiện o public final void notifyAll() ▪ Phương thức này thông báo tất cả các luồng đang chờ một sự kiện. Trong o số các luồng đã được thông báo, luồng nào có độ ưu tiên cao nhất thì sẽ chạy trước tiên. SlidSelid: es: ốs…ố 3.7\n\n[PAGE 38]\nVòng đời của luồng với wait-notify SlidSelid: es: ốs…ố 3.8\n\n[PAGE 39]\nVí dụ public class MessageBox",
    "source_id": "temp_cdb2bfe8-b7b1-4964-9ebb-7e389d642ead_2. Lập trình đa luồng (1).pdf",
    "title": "temp_cdb2bfe8-b7b1-4964-9ebb-7e389d642ead_2. Lập trình đa luồng (1)",
    "section": "",
    "section_level": 0,
    "page": 28,
    "course": "Unknown",
    "semester": "Unknown",
    "language": "vietnamese",
    "doc_type": "pdf",
    "keywords": [
      "count",
      "public",
      "synchronized",
      "void",
      "system",
      "slidselid",
      "page",
      "println",
      "nonsynchronizedcounter",
      "thread"
    ],
    "hash": "76944ab00feb736803a8021183060faf",
    "created_at": "2025-09-20T12:48:12.541691",
    "start_char": 7851,
    "end_char": 12320,
    "chunk_index": 2,
    "point_id": "12d0eddd-a47f-47f1-997b-ceed8a536bfc",
    "vector_index": 19
  },
  {
    "chunk_id": "60fe0bb2-1825-4e7e-9413-f73b02338d93",
    "content": "Nếu timeout bằng 0 thì phương thức sẽ chỉ chờ cho tới khi có cảnh báo về sự kiện. public final void notify() ▪ Cảnh báo ít nhất một luồng đang chờ một sự kiện o public final void notifyAll() ▪ Phương thức này thông báo tất cả các luồng đang chờ một sự kiện. Trong o số các luồng đã được thông báo, luồng nào có độ ưu tiên cao nhất thì sẽ chạy trước tiên. SlidSelid: es: ốs…ố 3.7\n\n[PAGE 38]\nVòng đời của luồng với wait-notify SlidSelid: es: ốs…ố 3.8\n\n[PAGE 39]\nVí dụ public class MessageBox { private String message; private boolean hasMessage; // producer phát ra một thông báo public synchronized void putMessage(String message) { while (hasMessage) { // có thông báo chưa được lấy try { wait(); // nhả khóa } catch (InterruptedException e) { } } // yêu cầu khóa và tiếp tục hasMessage = true; this.message = message + \" Put @ \" + System.nanoTime(); notify(); } SlidSelid: es: ốs…ố 3.9\n\n[PAGE 40]\nVí dụ // consumer lấy thông báo và hiển thị public synchronized String getMessage() { while (!hasMessage) { // không có thông báo mới try { wait(); // nhả khóa } catch (InterruptedException e) { } } // yêu cầu khóa để thực hiện hasMessage = false; notify(); return message + \" Get @ \" + System.nanoTime(); } } SlidSelid: es: ốs…ố 4.0\n\n[PAGE 41]\nVí dụ public class TestMessageBox { public static void main(String[] args) { final MessageBox box = new MessageBox(); Thread producerThread = new Thread() { @Override public void run() { System.out.println(\"Producer thread started...\"); for (int i = 1; i <= 6; ++i) { box.putMessage(\"message \" + i); System.out.println(\"Put message \" + i); } } }; SlidSelid: es: ốs…ố 4.1\n\n[PAGE 42]\nVí dụ Thread consumerThread1 = new Thread() { @Override public void run() { System.out.println(\"Consumer thread 1 started...\"); for (int i = 1; i <= 3; ++i) { System.out.println(\"Consumer thread 1 Get \" + box.getMessage()); } } }; SlidSelid: es: ốs…ố 4.2\n\n[PAGE 43]\nVí dụ Thread consumerThread2 = new Thread() { @Override public void run() { System.out.println(\"Consumer thread 2 started...\"); for (int i = 1; i <= 3; ++i) { System.out.println(\"Consumer thread 2 Get \" + box.getMessage()); } } }; consumerThread1.start(); consumerThread2.start(); producerThread.start(); } } SlidSelid: es: ốs…ố 4.3\n\n[PAGE 44]\nwait() với timeout SlidSelid: es: ốs…ố 4.4\n\n[PAGE 45]\nTIẾN TRÌNH TREO Slide: số….\n\n[PAGE 46]\nDeadlock và Livelock Deadlock là tình trạng các luồng phải chờ nhau vô hạn ▪ Deadlock thường xảy ra khi các bên chờ nhau giải phóng tài nguyên. ▪ Ví dụ: Luồng 1 đang gọi phương thức synchronized của đối tượng X và chờ khóa của đối tượng Y. Luồng 2 đang gọi phương thức synchronized của đối tượng Y và chờ khóa của đối tượng X. Livelock xảy ra khi trong chuỗi các luồng có lời gọi tới nhau, một ▪ luồng nào đó rơi vào trạng thái bận, làm cho tất cả các luồng sinh ra nó bị khóa. Starvation xảy ra khi tài nguyên bị một luồng chiếm dụng trong thời ▪ gian quá dài SlidSelid: es: ốs…ố 4.6\n\n[PAGE 47]\nDeadlock –Ví dụ public class TestThread { public static Object Lock1 = new Object(); public static Object Lock2 = new Object(); private static class ThreadDemo1 extends Thread { public void run() { synchronized (Lock1) { System.out.println(\"Thread 1: Holding lock 1...\"); try { Thread.sleep(10); } catch (InterruptedException e) {} System.out.println(\"Thread 1: Waiting for lock 2...\"); synchronized (Lock2) { System.out.println(\"Thread 1: Holding lock 1 & 2...\"); } } } } SlidSelid: es: ốs…ố 4.7\n\n[PAGE 48]\nDeadlock –Ví dụ (tiếp) private static class ThreadDemo2 extends Thread { public void run() { synchronized (Lock2) { System.out.println(\"Thread 2: Holding lock 2...\"); try { Thread.sleep(10); } catch (InterruptedException e) {} System.out.println(\"Thread 2: Waiting for lock 1...\"); synchronized (Lock1) { System.out.println(\"Thread 2: Holding lock 1 & 2...\"); } } } } public static void main(String args[]) { ThreadDemo1 T1 = new ThreadDemo1(); ThreadDemo2 T2 = new ThreadDemo2(); T1.start(); T2.start(); } SlidSelid: es: ốs…ố 4.8\n\n[PAGE 49]\nDeadlock –Ví dụ khác public class Deadlock { static class Friend { private final String name; public Friend(String name) { this.name = name; } public String getName() { return this.name; } public synchronized void bow(Friend bower) { System.out.format(\"%s: %s\" + \" has bowed to me!%n\", this.name, bower.getName()); bower.bowBack(this); } SlidSelid: es: ốs…ố 4.9\n\n[PAGE 50]\nDeadlock –Ví dụ khác (tiếp) public synchronized void bowBack(Friend bower) { System.out.format(\"%s: %s\" + \" has bowed back to me!%n\", this.name, bower.getName()); } } public static void main(String[] args) { final Friend alphonse = new Friend(\"Alphonse\"); final Friend gaston = new Friend(\"Gaston\"); new Thread(new Runnable() { public void run() { alphonse.bow(gaston); } }).start(); new Thread(new Runnable() { public void run() { gaston.bow(alphonse); } }).start(); } } SlidSelid: es:",
    "source_id": "temp_cdb2bfe8-b7b1-4964-9ebb-7e389d642ead_2. Lập trình đa luồng (1).pdf",
    "title": "temp_cdb2bfe8-b7b1-4964-9ebb-7e389d642ead_2. Lập trình đa luồng (1)",
    "section": "",
    "section_level": 0,
    "page": 38,
    "course": "Unknown",
    "semester": "Unknown",
    "language": "english",
    "doc_type": "pdf",
    "keywords": [
      "public",
      "thread",
      "system",
      "void",
      "slidselid",
      "page",
      "println",
      "synchronized",
      "string",
      "static"
    ],
    "hash": "dc1bf70822d2cb8a2d8ecc97e8f2b4a4",
    "created_at": "2025-09-20T12:48:12.542502",
    "start_char": 11831,
    "end_char": 16664,
    "chunk_index": 3,
    "point_id": "d5502589-6541-43e2-8e0d-cf980641982d",
    "vector_index": 20
  },
  {
    "chunk_id": "33684dd0-78ab-4f30-977b-36d527a22928",
    "content": "} public String getName() { return this.name; } public synchronized void bow(Friend bower) { System.out.format(\"%s: %s\" + \" has bowed to me!%n\", this.name, bower.getName()); bower.bowBack(this); } SlidSelid: es: ốs…ố 4.9\n\n[PAGE 50]\nDeadlock –Ví dụ khác (tiếp) public synchronized void bowBack(Friend bower) { System.out.format(\"%s: %s\" + \" has bowed back to me!%n\", this.name, bower.getName()); } } public static void main(String[] args) { final Friend alphonse = new Friend(\"Alphonse\"); final Friend gaston = new Friend(\"Gaston\"); new Thread(new Runnable() { public void run() { alphonse.bow(gaston); } }).start(); new Thread(new Runnable() { public void run() { gaston.bow(alphonse); } }).start(); } } SlidSelid: es: ốs…ố 5.0",
    "source_id": "temp_cdb2bfe8-b7b1-4964-9ebb-7e389d642ead_2. Lập trình đa luồng (1).pdf",
    "title": "temp_cdb2bfe8-b7b1-4964-9ebb-7e389d642ead_2. Lập trình đa luồng (1)",
    "section": "",
    "section_level": 0,
    "page": 50,
    "course": "Unknown",
    "semester": "Unknown",
    "language": "english",
    "doc_type": "pdf",
    "keywords": [
      "public",
      "friend",
      "void",
      "bower",
      "alphonse",
      "gaston",
      "getname",
      "name",
      "string",
      "synchronized"
    ],
    "hash": "eb63ec5870318511e61c5baf4e6103e6",
    "created_at": "2025-09-20T12:48:12.542676",
    "start_char": 15946,
    "end_char": 16673,
    "chunk_index": 4,
    "point_id": "48c75e17-c5ab-47ba-b18f-10bf86d7b328",
    "vector_index": 21
  },
  {
    "chunk_id": "805df263-585f-4d76-9e79-96572a64fc82",
    "content": "[PAGE 1]\nCHƯƠNG 3: Quản lý địa chỉ kết nối mạng với các lớp INetAddress, Url và UrlConnection Giảng viên: Ths. Phạm Văn Tiệp Slide: số….\n\n[PAGE 2]\nNội dung bài học ▪ Lớp InetAddress o Tạo đối tượng InetAddress o Các phương thức Getter o Các phương thức kiểm tra địa chỉ IP ▪ Lớp Url o Tạo các đối tượng Url o Nhận thông tin từ một Url o Phân tách một URL thành các phần thông tin ▪ Lớp UrlConnection SlideS:li dseố: …số .2\n\n[PAGE 3]\nLớp InetAddress Slide: số….\n\n[PAGE 4]\njava.net.InetAddress Chứa thông tin địa chỉ Internet của một nút mạng ▪ Các phương thức: ▪ static InetAddress getByName(String host): tạo một đối tượng InetAddress chứa o thông tin nút mạng có tên host static InetAddress[] getAllByName(String host) o static InetAddress getByAddress(byte[] addr): tạo một đối tượng InetAddress o chứa thông tin nút mạng có địa chỉ nằm trong mảng addr static InetAddress getByAddress(String host, byte[] addr) o static InetAddress getLocalHost(): tạo đối tượng InetAddress chứa thông tin máy o trạm cục bộ static InetAddress getLoopbackAddress(): tạo đối tượng InetAddress chứa thông o tin máy trạm cục bộ Slide: số….\n\n[PAGE 5]\nCác phương thức public String getHostName(): ▪ Phương thức này trả về một xâu biểu diễn tên (hostname) của một đối tượng o InetAddress. Nếu máy không có hostname, thì nó sẽ trả về địa chỉ IP của máy này dưới dạng o một xâu ký tự. public byte[] getAddress() : ▪ Trả về một địa chỉ IP dưới dạng một mảng các byte. o public boolean isReachable(int timeout) ▪ Kiểm tra kết nối tới máy trạm có địa chỉ trong đối tượng o InetAddress với timeout xác định Slide: số….\n\n[PAGE 6]\nVí dụ 1 try{ InetAddress host = InetAddress.getByName(“www.microsoft.com”); System.out.println(host); if(!host.isReachable(10000)) System.out.println(“Could not connect this host”); } catch(UnknownHostException e) { System.println(“Could not find this host”); } Slide: số….\n\n[PAGE 7]\nVí dụ 2 try{ byte[] addr = {8, 8, 8, 8}; InetAddress otherHost = InetAddress.getByAddress(addr); if(!otherHost.isReachable(10000)) System.out.println(“Could not connect this host”) } catch(UnknownHostException e) { System.println(“Could not find this host”); } Slide: số….\n\n[PAGE 8]\nLớp Url Slide: số….\n\n[PAGE 9]\nĐịa chỉ URL Uniform Resource Locator: định vị tài nguyên trên mạng ▪ Cấu trúc: ▪ protocol://hostname:port/directory/URI protocol: Giao thức điều khiển truy cập tài nguyên hostname: Địa chỉ nút mạng vật lý (tên miền,địa chỉ IP) port: Số hiệu cổng dịch vụ (có thể không cần nếu server sử dụng cổng chuẩn) directory: đường dẫn thư mục URI: định danh tài nguyên (thường là tên file) Slide: số….\n\n[PAGE 10]\nLớp java.net.URL Nằm tại java.net.URL để thực hiện các thao tác định vị tài nguyên ▪ Đối tượng URL bao gồm các thuộc tính: ▪ Giao thức (protocol) o Hostname o Cổng (port) o Đường dẫn (path) o Tên tập tin (filename) o Mục tài liệu (document section) o Slide: số….\n\n[PAGE 11]\nCác constructor của URL public URL(String url) throws MalformedURLException Chỉ chứa xâu địa chỉ URL (như dạng website) Ví dụ try{ URL u = new URL(“http://www.sun.com/index.html”); } catch(MalformedURLException e) { System.err.println(e); } Slide: số….\n\n[PAGE 12]\nCác constructor của URL public URL(String protocol, String host, String file) throws MalformedURLException URL xây dựng từ các xâu phân biệt xác định giao thức, o hostname, và tệp tin. Cổng mặc định cho giao thức sẽ được sử dụng. o Ví dụ try{ URL u = new URL(“http”,”/www.sun.com”,”index.html”); } catch(MalformedURLException e){ System.err.println(e); } Slide: số….\n\n[PAGE 13]\nCác constructor của URL public URL(String protocol, String host, int port, String file) throws MalformedURLException Bổ sung tham số cổng. o Ví dụ try{ URL u = new URL(“http”,”/www.sun.com”,80,”index.html”); } catch(MalformedURLException e){ System.err.println(e); } Slide: số….\n\n[PAGE 14]\nCác constructor của URL public URL(URL protocol, String host) throws MalformedURLException URL tuyệt đối từ URL tương đối. o Ví dụ URL u1, u2; try{ URL u1 = new URL(“http://www.macfaq.com/index.html”); URL u2 = new URL(u1,”vendor.html”); } catch(MalformedURLException e){ System.err.println(e); } Slide: số….\n\n[PAGE 15]\nCác phương thức public String getProtocol() ▪ Trả về một xâu ký tự biểu diễn phần giao thức của URL o public String getHost() ▪ Trả về một xâu ký tự biểu diễn phần hostname của URL. o public int getPort() ▪ Trả về một số nguyên kiểu int biểu diễn số hiệu cổng có trong o URL. public int getDefaultPort() ▪ Phương thức getDefautlPort() trả về số hiệu cổng mặc định cho o giao thức của URL public String getFile() ▪ Trả về một xâu ký tự chứa đường dẫn tới tài nguyên o Slide: số….\n\n[PAGE 16]\nCác phương thức public final InputStream openStream() ▪ Đọc dữ liệu từ tài nguyên đã truy cập được o Dữ liệu nhận từ luồng này là dữ liệu thô của một tệp tin mà o URL tham chiếu (mã ASCII nếu",
    "source_id": "temp_2e57a38f-0f0b-4ce2-b6fe-f3dcf572b8ed_3. Quản lý địa chỉ kết nối mạng với các lớp INetAddress, Url và UrlConnection (1).pdf",
    "title": "temp_2e57a38f-0f0b-4ce2-b6fe-f3dcf572b8ed_3. Quản lý địa chỉ kết nối mạng với các lớp INetAddress, Url và UrlConnection (1)",
    "section": "",
    "section_level": 0,
    "page": 1,
    "course": "Unknown",
    "semester": "Unknown",
    "language": "vietnamese",
    "doc_type": "pdf",
    "keywords": [
      "inetaddress",
      "page",
      "string",
      "slide",
      "host",
      "public",
      "system",
      "println",
      "malformedurlexception",
      "hostname"
    ],
    "hash": "c09d9bd7943ad69e9ee18e651d726899",
    "created_at": "2025-09-20T12:48:13.156127",
    "start_char": 2,
    "end_char": 4809,
    "chunk_index": 0,
    "point_id": "7582705e-e2ce-4fc5-b6ab-c2be3d36817f",
    "vector_index": 22
  },
  {
    "chunk_id": "61b02460-252e-4917-97da-5a527773196c",
    "content": "getPort() ▪ Trả về một số nguyên kiểu int biểu diễn số hiệu cổng có trong o URL. public int getDefaultPort() ▪ Phương thức getDefautlPort() trả về số hiệu cổng mặc định cho o giao thức của URL public String getFile() ▪ Trả về một xâu ký tự chứa đường dẫn tới tài nguyên o Slide: số….\n\n[PAGE 16]\nCác phương thức public final InputStream openStream() ▪ Đọc dữ liệu từ tài nguyên đã truy cập được o Dữ liệu nhận từ luồng này là dữ liệu thô của một tệp tin mà o URL tham chiếu (mã ASCII nếu đọc một tệp văn bản, mã HTML nếu đọc một tài liệu HTML, một ảnh nhị phân nếu ta đọc một file ảnh). public URLConnection openConnection() ▪ Trả về một URLConnection kết nối với tài nguyên o Slide: số….\n\n[PAGE 17]\nVí dụ url = new URL(\"http://dainam.edu.vn/index.htm\"); try(BufferedReader br = new BufferedReader(new InputStreamReader(url.openStream()))){ String line; while((line = br.readLine()) != null) System.out.println(line); } catch(IOException e){ System.out.println(e.getMessage()); } Slide: số….\n\n[PAGE 18]\nLớp UrlConnection Slide: số….\n\n[PAGE 19]\nLớp URLConnection Cung cấp thêm nhiều phương thức hơn để tương tác với tài ▪ nguyên Các lớp con: HttpURLConnection, HttpsURLConnection ▪ Các phương thức: ▪ InputStream getInputStream(): đọc dữ liệu từ URLConnection o OutputStream getOutputStream(): ghi dữ liệu lên o URLConnection Đọc thêm về URLConnection và các lớp con trong tài liệu của ▪ Java Slide: số….\n\n[PAGE 20]\nLớp URLConnection ▪ Cung cấp nhiều sự điều khiển hơn khi tương tác với server o Có thể đọc và cấu hình các header HTTP của một kết nối. ▪ Có thể đọc và ghi dữ liệu vào tài nguyên trên server được định vị trí bởi URLs o Cho phép gửi dữ liệu lên server thông qua một số phương thức HTTP request khác nhau: POST, PUT hay các phương thức khác. Slide: số….\n\n[PAGE 21]\nMở một URLConnection ▪ Chương trình sử dụng lớp URLConnection thường trải qua các bước sau: o (1) Tạo một đối tượng URL o (2) Gọi phương thức openConnection() của đối tượng URL để tạo đối tượng URLConnection o (3) Cấu hình URLConnection o (4) Đọc các trường thông tin header o (5) Lấy một stream nhập và đọc dữ liệu o (6) Lấy một stream xuất và ghi dữ liệu o (7) Đóng kết nối ▪ Chương trình không nhất thiết phải thực hiện đầy đủ các bước như trên. Slide: số….\n\n[PAGE 22]\nĐọc dữ liệu từ Server ▪ Các bước đọc dữ liệu từ server: o (1) Tạo một đối tượng URL o (2) Gọi phương thức openConnection() của đối tượng URL để tạo đối tượng URLConnection o (3) Gọi phương thức getInputStream() của đối tượng URLConnection o (4) Đọc dữ liệu từ stream nhập nhận được ▪ Phương thức lấy một stream đọc dữ liệu o public InputStream getInputStream( ) Slide: số….",
    "source_id": "temp_2e57a38f-0f0b-4ce2-b6fe-f3dcf572b8ed_3. Quản lý địa chỉ kết nối mạng với các lớp INetAddress, Url và UrlConnection (1).pdf",
    "title": "temp_2e57a38f-0f0b-4ce2-b6fe-f3dcf572b8ed_3. Quản lý địa chỉ kết nối mạng với các lớp INetAddress, Url và UrlConnection (1)",
    "section": "",
    "section_level": 0,
    "page": 16,
    "course": "Unknown",
    "semester": "Unknown",
    "language": "vietnamese",
    "doc_type": "pdf",
    "keywords": [
      "urlconnection",
      "slide",
      "page",
      "public",
      "server",
      "stream",
      "inputstream",
      "openconnection",
      "http",
      "line"
    ],
    "hash": "88372037c8d59dcca89c47d4a2311e85",
    "created_at": "2025-09-20T12:48:13.159812",
    "start_char": 4323,
    "end_char": 6945,
    "chunk_index": 1,
    "point_id": "181ec340-4bee-4e88-b4c2-425c69a20cbc",
    "vector_index": 23
  },
  {
    "chunk_id": "ad55da9a-dcc4-4e51-88e0-0c8076042979",
    "content": "[PAGE 1]\nCHƯƠNG 4: Lập trình với giao thức TCP Giảng viên: Ths. Phạm Văn Tiệp Slide: số….\n\n[PAGE 2]\nNội dung bài học ▪ Mô hình Client/Server ▪ Mô hình truyền tin Socket ▪ Lớp Socket ▪ Lớp ServerSocket ▪ Các bước xây dựng ứng dụng Server ▪ Các bước xây dựng ứng dụng Client ▪ Đa luồng trong lập trình Socket SlideS:li dseố: …số .2\n\n[PAGE 3]\nMô hình Client/Server Slide: số….\n\n[PAGE 4]\nMô hình Client Server Client Server là một kiến trúc phần mềm có 2 thành phần chính: ▪ Client (máy khách): Là người dùng hoặc ứng dụng cuối cùng có trách nhiệm o gửi yêu cầu đến server và xử lý kết quả trả về từ server Server (máy chủ): Là nơi xử lý yêu cầu từ client và cung cấp dữ liệu hoặc o dịch vụ tương ứng. Có nhiệm vụ lắng nghe và đáp ứng các yêu cầu từ client Giao tiếp giữa Client và Server: ▪ Thông qua các giao thức HTTP, HTTPS, TCP/IP,… o Client gửi yêu cầu (request) đến Server và đợi nhận lại phản hồi (response) từ o Server Slide: số….\n\n[PAGE 5]\nMô hình truyền tin Socket Slide: số….\n\n[PAGE 6]\nSocket là gì? Socket là công cụ để các ứng dụng trao đổi dữ liệu ▪ Trên kiến trúc phân tầng của hệ thống mạng, socket là dịch vụ mà tầng giao vận cung cấp ▪ cho tầng ứng dụng Hai dạng socket: ▪ TCP socket o UDP socket o Ứng dụng sử dụng TCP Socket: ▪ Lớp Socket: sử dụng để client và server trao đổi dữ liệu o Lớp ServerSocket: sử dụng tại ứng dụng server để nghe yêu cầu kết nối từ client o Ứng dụng sử dụng UDP Socket: ▪ Lớp DatagramSocket: truyền tải dữ liệu o Lớp DatagramPacket: xử lý dữ liệu o Slide: số….\n\n[PAGE 7]\nLớp Socket Slide: số….\n\n[PAGE 8]\nLớp Socket InetAddress getInetAddress(): lấy địa chỉ của bên kia ▪ int getPort(): lấy số hiệu cổng của bên kia ▪ int getLocalPort(): lấy số hiệu cổng trên nút mạng cục bộ mà ứng dụng đang chạy ▪ InetAddress getLocalAddress(): lấy địa chỉ trên nút mạng cục bộ ▪ InputStream getInputStream(): trả về luồng InputStream để nhận dữ liệu ▪ OutputStream getOutputStream(): trả về luồng OutputStream để gửi dữ liệu ▪ Gửi-nhận dữ liệu trên socket giống vào-ra trên file o Slide: số….\n\n[PAGE 9]\nCác phương thức InetAddress getInetAddress(): lấy địa chỉ của bên kia ▪ int getPort(): lấy số hiệu cổng của bên kia ▪ int getLocalPort(): lấy số hiệu cổng trên nút mạng cục bộ mà ứng dụng đang chạy ▪ InetAddress getLocalAddress(): lấy địa chỉ trên nút mạng cục bộ ▪ InputStream getInputStream(): trả về luồng InputStream để nhận dữ liệu ▪ OutputStream getOutputStream(): trả về luồng OutputStream để gửi dữ liệu ▪ Gửi-nhận dữ liệu trên socket giống vào-ra trên file o Slide: số….\n\n[PAGE 10]\nCác phương thức void setSoTimeout(int timeout): thiết lập thời gian chờ ▪ void setSendBufferSize(int size): thiết lập kích thước bộ đệm gửi ▪ void setReceiveBufferSize(int size): thiết lập kích thước bộ đệm nhận ▪ void close(): đóng socket cả 2 chiều gửi-nhận ▪ void shutdownInput(): đóng socket chiều nhận ▪ void shutdownOutput(): đóng socket chiều gửi ▪ boolean isInputShutdown(): kiểm tra tình trạng đóng chiều nhận ▪ boolean isOutputShutdown(): kiểm tra tình trạng đóng chiều gửi ▪ Slide: số….\n\n[PAGE 11]\nLớp ServerSocket Slide: số….\n\n[PAGE 12]\nLớp ServerSocket Các phương thức khởi tạo: sau khi được khởi tạo, ServerSocket tự động thiết lập ▪ trạng thái chờ yêu cầu tạo kết nối TCP từ client gửi tới ServerSocket(int port): tạo ServerSocket với số hiệu cổng port chỉ định ▪ Ngoại lệ sinh ra khi cổng đã được sử dụng hoặc sử dụng một o cổng trong dải cổng chuẩn 0-1023. ServerSocket(int port, int max): tạo ServerSocket với số kết nối tối đa chấp nhận là ▪ max ServerSocket(int port, int max, InetAddress addr): tạo ServerSoket với địa chỉ IP và ▪ số hiệu cổng chỉ định Slide: số….\n\n[PAGE 13]\nCác phương thức Socket accept(): chấp nhận yêu cầu xin kết nối từ client, trả về một đối tượng ▪ Socket để trao đổi dữ liệu với client đó. void close(): đóng ServerSocket ▪ void setSoTimeout(int timeout): thiết lập thời gian chờ ▪ void setSendBufferSize(int size): thiết lập kích thước bộ đệm gửi ▪ void setReceiveBufferSize(int size): thiết lập kích thước bộ đệm nhận ▪ InetAddress getInetAddress() ▪ int getLocalPort() ▪ Slide: số….\n\n[PAGE 14]\nCác bước xây dựng ứng dụng Server Slide: số….\n\n[PAGE 15]\nCác bước xây dựng ứng dụng server B1: Khởi tạo một đối tượng ServerSocket để nghe yêu cầu kết nối từ client ▪ Sử dụng một vòng lặp để thực",
    "source_id": "temp_feefc5a9-c199-4267-a58e-cc6048e0cf64_4. Lập trình với giao thức TCP (2).pdf",
    "title": "temp_feefc5a9-c199-4267-a58e-cc6048e0cf64_4. Lập trình với giao thức TCP (2)",
    "section": "",
    "section_level": 0,
    "page": 1,
    "course": "Unknown",
    "semester": "Unknown",
    "language": "vietnamese",
    "doc_type": "pdf",
    "keywords": [
      "socket",
      "client",
      "page",
      "server",
      "slide",
      "serversocket",
      "void",
      "inetaddress",
      "giao",
      "inputstream"
    ],
    "hash": "27cbf46f3ff8f273571cdf2c16114509",
    "created_at": "2025-09-20T12:48:13.708205",
    "start_char": 2,
    "end_char": 4265,
    "chunk_index": 0,
    "point_id": "b0fa0d4f-2eae-4729-ba88-3cad38b9b66a",
    "vector_index": 24
  },
  {
    "chunk_id": "c4492f38-ef0e-4e2b-b2a2-1fc7044fefa4",
    "content": "một đối tượng ▪ Socket để trao đổi dữ liệu với client đó. void close(): đóng ServerSocket ▪ void setSoTimeout(int timeout): thiết lập thời gian chờ ▪ void setSendBufferSize(int size): thiết lập kích thước bộ đệm gửi ▪ void setReceiveBufferSize(int size): thiết lập kích thước bộ đệm nhận ▪ InetAddress getInetAddress() ▪ int getLocalPort() ▪ Slide: số….\n\n[PAGE 14]\nCác bước xây dựng ứng dụng Server Slide: số….\n\n[PAGE 15]\nCác bước xây dựng ứng dụng server B1: Khởi tạo một đối tượng ServerSocket để nghe yêu cầu kết nối từ client ▪ Sử dụng một vòng lặp để thực hiện các bước 2-5: B2: Gọi phương thức accept() để chấp nhận. Phương thức này trả về một đối tượng ▪ Socket để trao đổi dữ liệu với client. B3: sử dụng phương thức getInputStream() và getOutputStream() lấy các luồng ▪ vào-ra để trao đổi dữ liệu với client B4: Trao đổi dữ liệu với client ▪ B5: Đóng socket kết nối với client ▪ B6: Đóng SeverSocket ▪ Slide: số….\n\n[PAGE 16]\nVí dụ public class TCPEchoServer { public final static int DEFAULT_PORT = 5000; public static void main(String[] args) { try(ServerSocket servSocket = new ServerSocket(DEFAULT_PORT)){ while (true){ Socket connSocket = servSocket.accept(); System.out.println(“Accepted client:\" + connSocket.getInetAddress().getHostAddress()); try(BufferedReader in = new BufferedReader(new InputStreamReader(connSocket.getInputStream())); PrintWriter out = new PrintWriter(new OutputStreamWriter(connSocket.getOutputStream())) ){ Slide: số….\n\n[PAGE 17]\nVí dụ String message; while((message = in.readLine()) != null){ System.out.println(\"Receive from client:\" + message); out.println(message); out.flush(); } System.out.println(\"Client has stopped sending data!\"); }catch (IOException e){ System.out.println(e.getMessage()); } } }catch (IOException e){ System.out.println(e.getMessage()); } } } Slide: số….\n\n[PAGE 18]\nCác bước xây dựng ứng dụng Client Slide: số….\n\n[PAGE 19]\nCác bước xây dựng ứng dụng client B1: Khởi tạo một đối tượng Socket để kết nối với server ▪ B2: sử dụng phương thức getInputStream() và getOutputStream() ▪ lấy các luồng vào-ra để trao đổi dữ liệu với server Gửi-nhận dữ liệu với Socket giống vào-ra trên file o Cần sử dụng linh hoạt các loại luồng vào-ra trong Java o B3: Trao đổi dữ liệu với server ▪ B4: Đóng socket ▪\n\n[PAGE 20]\nCác bước xây dựng ứng dụng client B1: Khởi tạo một đối tượng Socket để kết nối với server ▪ B2: sử dụng phương thức getInputStream() và getOutputStream() lấy các luồng ▪ vào-ra để trao đổi dữ liệu với server Gửi-nhận dữ liệu với Socket giống vào-ra trên file o Cần sử dụng linh hoạt các loại luồng vào-ra trong Java o B3: Trao đổi dữ liệu với server ▪ B4: Đóng socket ▪ Slide: số….\n\n[PAGE 21]\nVí dụ public class TCPEchoClient { public static void main(String[] args) { try(Socket clientSocket = new Socket(\"localhost\", 5000); BufferedReader user = new BufferedReader(new InputStreamReader(System.in)); BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream())); PrintWriter out = new PrintWriter(new OutputStreamWriter(clientSocket.getOutputStream())) ){ String message; while(true){ System.out.print(\"Send to server: \"); message = user.readLine(); if(message.length() == 0) break; Slide: số….\n\n[PAGE 22]\nVí dụ out.println(message); out.flush(); String reply; reply = in.readLine(); System.out.println(\"Reply from Server:\" + reply); } clientSocket.close(); }catch (IOException e){ System.out.println(e.getMessage()); } } } Slide: số….\n\n[PAGE 23]\nĐa luồng trong lập trình Socket Slide: số….\n\n[PAGE 24]\nĐa luồng trong lập trình Socket Với các ví dụ trên → 1 server tại một thời điểm chỉ xử lí một client → không thể ▪ đáp ứng nhiều yêu cầu một lúc Sử dụng đa luồng để khắc phục nhược điểm ▪ Khi có một client kết nối đến server (accept trả về) o Tạo ra một luồng để xử lí công việc với client đó o Slide: số….\n\n[PAGE 25]\nVí dụ public class TCPEchoThread implements Runnable{ private Socket socket; public EchoThread(Socket s){ socket = s; } public void run(){ try(BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream())); PrintWriter out = new PrintWriter(new OutputStreamWriter(socket.getOutputStream())) ){ String message; Slide: số….\n\n[PAGE 26]\nVí dụ while((message = in.readLine()) != null){ System.out.println(\"Receive from client:\" + message); out.println(message); out.flush(); } System.out.println(\"Client has stopped sending data!\"); socket.close(); }catch (IOException e){ System.out.println(e.getMessage()); } } } Slide: số….\n\n[PAGE 27]\nVí dụ public class MultiThreadTCPEchoServer { public final static int DEFAULT_PORT = 5000; public static void main(String[] args) { try(ServerSocket servSocket = new ServerSocket(DEFAULT_PORT) ){ while(true){ Runnable t = new TCPEchoThread(servSocket.accept()); new Thread(t).start(); } }catch(IOException e){ System.out.println(e.getMessage()); } } } Slide: số….",
    "source_id": "temp_feefc5a9-c199-4267-a58e-cc6048e0cf64_4. Lập trình với giao thức TCP (2).pdf",
    "title": "temp_feefc5a9-c199-4267-a58e-cc6048e0cf64_4. Lập trình với giao thức TCP (2)",
    "section": "",
    "section_level": 0,
    "page": 14,
    "course": "Unknown",
    "semester": "Unknown",
    "language": "english",
    "doc_type": "pdf",
    "keywords": [
      "socket",
      "client",
      "slide",
      "page",
      "println",
      "system",
      "server",
      "message",
      "public",
      "trao"
    ],
    "hash": "add50c2b3345a4d3c1b088b38cee8642",
    "created_at": "2025-09-20T12:48:13.709056",
    "start_char": 3705,
    "end_char": 8550,
    "chunk_index": 1,
    "point_id": "c88ae889-bb95-448b-ad22-efd2bebc6f76",
    "vector_index": 25
  },
  {
    "chunk_id": "dd5e5eaf-aab1-405f-bad2-2f942e33ed6b",
    "content": "System.out.println(e.getMessage()); } } } Slide: số….",
    "source_id": "temp_feefc5a9-c199-4267-a58e-cc6048e0cf64_4. Lập trình với giao thức TCP (2).pdf",
    "title": "temp_feefc5a9-c199-4267-a58e-cc6048e0cf64_4. Lập trình với giao thức TCP (2)",
    "section": "",
    "section_level": 0,
    "page": 27,
    "course": "Unknown",
    "semester": "Unknown",
    "language": "english",
    "doc_type": "pdf",
    "keywords": [
      "system",
      "println",
      "getmessage",
      "slide"
    ],
    "hash": "3279f05597ee371a62ea80526fcda401",
    "created_at": "2025-09-20T12:48:13.709121",
    "start_char": 8497,
    "end_char": 8550,
    "chunk_index": 2,
    "point_id": "ca5cf6da-de36-47ee-ae3c-8afbfb62073c",
    "vector_index": 26
  },
  {
    "chunk_id": "0476411e-b2b9-433c-8aed-474bceb1c3ac",
    "content": "This is a test document for persistence check.",
    "source_id": "temp_4d5094e5-cc3e-4872-9667-29c3af2897b2_test_doc.txt",
    "title": "temp_4d5094e5-cc3e-4872-9667-29c3af2897b2_test_doc",
    "section": "",
    "section_level": 0,
    "page": null,
    "course": "Unknown",
    "semester": "Unknown",
    "language": "english",
    "doc_type": "markdown",
    "keywords": [
      "test",
      "document",
      "persistence",
      "check"
    ],
    "hash": "83ee7f0f7ff672c3829b9f45ab674bb3",
    "created_at": "2025-09-20T14:22:55.701891",
    "start_char": 0,
    "end_char": 46,
    "chunk_index": 0,
    "point_id": "94abf520-f6e7-4e32-b073-5beb94b520b1",
    "vector_index": 27
  }
]